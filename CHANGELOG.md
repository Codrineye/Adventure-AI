## Version History

### Workspace Import
Use this if you want a copy of the source for modifying in the editor.
```
{"workspaces":{"Adventure":[["init",":import adventure_lib\n:name {package}:init\n\n:budget_cap 1\n\n:const string hide_block \"adv---Stop hiding---\"\n#hide_blocker global.string.get(hide_block)\n\n:global int leon.adventure.maxDifficulty\n:global bool leon.adventure.running\n:global string leon.adventure.path\n:global string leon.adventure.room_direction\n\n:local int maxDifficultyInit\n:local double difficulty\n\nkey.{start}()\nkey.{reinit}()\n\nisopen(\"arcade\")\n\n#nextRoomLower if(\\\n  x(adventure.roomCoords()) < 127.0 && y(adventure.roomCoords()) >= 127.0,\\\n  \"R\",\\\n  if(\\\n    x(adventure.roomCoords()) >= 127.0 && y(adventure.roomCoords()) > 127.0,\\\n    \"D\",\\\n    if(\\\n      x(adventure.roomCoords()) > 127.0 && y(adventure.roomCoords()) <= 127.0,\\\n      \"L\",\\\n      \"U\" \\\n    )\\\n  )\\\n)\n#rotateLeft(x) sub(\"LDRU\", index(\"ULDR\", {x}, 0), 1)\n; Conditionally rotate the direction \"x\" to the left.\n; The benefit of this macro is that it only expands \"x\" once.\n#condRotateLeft(cond, x) sub(if({cond}, \"LDRU\", \"ULDR\"), index(\"ULDR\", {x}, 0), 1)\n\n; ======== Start init code ==============\n\n; This exists as a local variable solely to provide users an easy place to\n; customize it, after it's been imported.\nmaxDifficultyInit = 81\n\n; Initialize all our global variables.\n; This is a maze of conditional expressions, because init is called from\n; *every* script that has a key impulse, in order to handle proper variable\n; initialization first.\n\n; Check the variable hider to see if this is first execution or not.\nleon.adventure.maxDifficulty = if(\\\n  contains(\"\", {hide_blocker}) || {contains.key({reinit})},\\\n  maxDifficultyInit,\\\n  leon.adventure.maxDifficulty\\\n)\n; This variable also begins the variable hiding block with its name.\nglobal.string.set({target_pos_var}, {target_positions})\n\n; If we are triggered by key.r or key.k (from the kill enemies script), then\n; we should toggle the running state. This expression toggles the state when\n; the second part is true, and keeps it constant when the second part is false.\nleon.adventure.running = leon.adventure.running !=\\\n    contains(\"key.{start}|{package}:kill enemies\", impulse())\nleon.adventure.path = leon.adventure.path\nleon.adventure.room_direction = leon.adventure.room_direction\nglobal.string.set(hide_block, \"</size>\")\n\n; If we are invoked from \"kill enemies,\" it means we are using that script stand-alone.\n; We will execute the last executesync of the loop below, just to re-exec the\n; kill-enemies script. This is done to keep all the init and turbo start/stop logic\n; centralized here, in init.\n; In general, \"contains\" checks are more size/speed efficient than \"==\" checks\n; for strings, since they have one fewer argument.\ngoto(if(\\\n  contains(impulse(), \"kill enemies\"),\\\n  last_exec,\\\n  if({contains.key({start})} && leon.adventure.running, loop, end)\\\n))\n\n; ======== Continuous loop code ==============\n\nloop:\nexecutesync(\"{package}:farm keys\")\n\n; We check based on current difficulty plus 1, because it's more efficient\n; that way.\ndifficulty = {cur_difficulty(1.0)}\n\n; This line is responsible for maxDifficulty \"creeping\" upwards. When used\n; properly, it will cause the AI to slowly make spirals that cover (nearly)\n; the entire maze. However, extra lines can \"trick\" it and cause it to jump\n; more difficulty levels than wanted.\n;\n; Note the check against current difficulty (which is current_difficulty+1 here),\n; which prevents this from triggering multiple times before the AI can travel\n; to new rooms.\n;\n; We add 2 to maxDifficulty because adding 1 would cause us to overlap\n; prior progress, and we'd immediately add another 1 anyway.\nleon.adventure.maxDifficulty = if(\\\n  difficulty > i2d(leon.adventure.maxDifficulty) \\\n    && adventure.isCompleted(adventure.roomCoords()),\\\n  leon.adventure.maxDifficulty + 2,\\\n  leon.adventure.maxDifficulty\\\n)\n\n; using contains here saves 1 block, but you might not like it\nleon.adventure.room_direction = if(\\\n  difficulty == 1.0 || contains(\"\", leon.adventure.room_direction),\\\n  {condRotateLeft({survivable(difficulty)}, {nextRoomLower})},\\\n  {rotateLeft(leon.adventure.room_direction)}\\\n)\n\nlast_exec:\n; We might be here to invoke \"kill enemies\", which happens iff we ourselves were\n; invoked by \"kill enemies.\" Otherwise, we need to protect against arcade being closed,\n; because executesync will stall forever in that case due to the script condition.\n; This also prevents spurious moves in case we've cancelled the script.\nexecutesync(if(\\\n  contains(impulse(), \"kill enemies\"),\\\n  \"{package}:kill enemies\",\\\n  if(\\\n    isopen(\"arcade\") && leon.adventure.running,\\\n    \"{package}:find loot\",\\\n    \"{package}:xNOOPx\"\\\n  )\\\n))\ngotoif(loop, isopen(\"arcade\") && leon.adventure.running && not(contains(impulse(), \"kill enemies\")))\n\nend:\n; If we were invoked by a manual action (key.r or kill enemies), we shut down\n; automatically once we reach the end of the script. This might be redundant, but\n; in some cases (such as exiting due to leaving the arcade) it is needed.\n; In any other situation, the running state should be unmodified.\nleon.adventure.running = leon.adventure.running &&\\\n  not(contains(\"key.{start}|{package}:kill enemies\", impulse()))\n"],["analyze loot",":import adventure_lib\n:name {package}:analyze loot\n\n:budget_cap max\n\n:local string queue\n:local string idx\n:local vector curPos\n:local string targetPos\n:local string lootPositions\n\n#setField(index, value) lss(\"_f\" . {index}, {value})\n#getField(index) lsg(\"_f\" . {index})\n#setTPos(index, value) lss(\"_t\" . {index}, {value})\n#getTPos(index) lsg(\"_t\" . {index})\n\nqueue = {vecToString(adventure.playerPos())} . \"S:\"\n\n; On the first entry of this loop, the junk entry \"_f\" will be set to \"S\".\n; This has no effect.\n; In general, lootPositions, queue and setField are protected so that if the field\n; has already been set, we won't take action again.\nloop1:\ncurPos = {firstElementPos}\nidx = sub(queue, 0, 4)\n\n; Add a position if it's not been processed and if it has a chest in it\nlootPositions = if(\\\n  {getField(idx)} == \"\" && contains(adventure.entityType(curPos), \"Chest\"),\\\n  {vecToString(curPos)} . \":\" . lootPositions,\\\n  lootPositions\\\n)\n{setField(if({getField(idx)} != \"\", \"\", idx), {firstElementDir})}\n\n; If we've not added a position, pop the processed position\n; otherwise, pop the processed position and look at\n; the neighbouring 4 positions and\n; add all non-wall positions to the queue\nqueue = if(\\\n  {getField(idx)} != {firstElementDir},\\\n  sub(queue, 6, 99999),\\\n  sub(queue, 6, 99999) . if(\\\n    adventure.isWall(curPos + vec(0.0, 1.0)) || y(curPos) >= 18.0,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) + 1.0)} . \"U:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(0., -1.0)) || y(curPos) < 1.0,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) - 1.0)} . \"D:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(1., 0.0)) || x(curPos) >= 18.0,\\\n    \"\",\\\n    {posToString(x(curPos) + 1.0, y(curPos))} . \"R:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(-1.0, 0.)) || x(curPos) < 1.0,\\\n    \"\",\\\n    {posToString(x(curPos) - 1.0, y(curPos))} . \"L:\"\\\n  )\\\n)\n; Every position is ended with `:` so we should\n; repeat the loop until queue no longer has the character `:`\n; i.e until we've added a field for every tile in the room\ngotoif(loop1, contains(queue, \":\"))\n\ncontinue:\nlootPositions = {target_positions} . lootPositions\n; add the loot positions to our target positions\n\nloop2:\ntargetPos = sub(lootPositions, 0, 4) ; get the next loot position\ncurPos = {strToVec(targetPos)} ; set our curPos to our position\nlootPositions = sub(lootPositions, 5, 99999) ; pop the previous loot position\n\ninnerLoop2:\nidx = {vecToString(curPos)} ; stringify our curPos to access our fields\n\n; you could do contains(getField(vecToString(curPos - nextDir(getField(idx))))) here\n; but I don't know if the extra block count is worth it\n; \n; lsg = 1\n; concat = 2\n; sub = 3\n; d2s = 2\n; posToString = concat + sub + d2s + sub + d2s = 12\n; a.d = 3\n; x = 1\n; index = 3\n; nextX = nextY = s2d + sub + index = 8\n; getField = lsg + concat = 3\n; comparison.string = 3\n; 3 + 12 + 3 + 1 + 8 + 3 + 1 + 8 + 3 = 42\n; \n; vecToString = x + y + posToString = 1 + 1 + 12 = 14\n; a.v = a.d = 3\n; nextDir = vec + nextX + nextY = 18\n; 3 + 14 + 3 + 18 = 38\n\n; insert our loot positions into our target_positions\n; \n; make our loot position the head if it can be accessed by our start and\n; it hasn't already been added to the target_positions\n; \n; otherwise, don't insert if the target position hasn't been recorded yet or\n; if it has already been inserted in our target_positions\n; \n; otherwise, insert a step to reach our loot position?\nglobal.string.set({target_pos_var}, if(\\\n  \"S\" == {getField({vecToString(curPos - {nextDir({getField(idx)})})})} \\\n    && not(contains({target_positions}, targetPos)),\\\n  targetPos . \":\" . {target_positions},\\\n  if(\\\n    contains({target_positions}, targetPos) || contains(\"\", {getTPos(idx)}),\\\n    {target_positions},\\\n    sub({target_positions}, 0, index({target_positions}, {getTPos(idx)}, 0))\\\n      . targetPos . \":\" \\\n      . sub({target_positions}, index({target_positions}, {getTPos(idx)}, 0), 99999)\\\n  )\\\n))\n\n; set a target position if it hasn't been added to the target_positions\n; or overwrite the target position if its contents is with target positions?\n{setTPos(\\\n  idx,\\\n  if(\\\n    not(contains({target_positions}, targetPos)) || contains(\\\n      {getTPos(idx)}, \\\n      sub({target_positions}, index({target_positions}, targetPos, 0) + 5, 4)\\\n    ),\\\n    targetPos,\\\n    {getTPos(idx)}\\\n  )\\\n)}\n\n; Update our curPos to the next tile\n; \n; We're actually working backwards, from the desired loot position back to\n; our starting position, so this \"next tile\" is a tile closer to the player\ncurPos = curPos - {nextDir({getField(idx)})}\n; return to the innerLoop2 if we've not made our way back to the starting position\n; if we have, move back to loop2 if there's more loot positions to add\ngoto(if(\\\n  {getField({vecToString(curPos)})} != \"S\",\\\n  innerLoop2,\\\n  if(contains(\"\", lootPositions), end, loop2)\\\n))\n; contains(\"\", lootPositions) is true only when len(lootPositions) == 0\n\nend:\nwait(0.)\n"],["farm keys",":import adventure_lib\n:name {package}:farm keys\n\n:budget_cap 1\n\n:global int leon.adventure.maxDifficulty\n:global bool leon.adventure.running\n:global string leon.adventure.path\n\n:local double difficulty\n:local bool parity\n:local bool needs_something\n:local bool skipped\n\n:local string dir\n\n#can_leech adventure.hasItem(\"leechSword\")\n#can_cast adventure.hasItem(\"bookSpells\")\n\n#needs_bombs adventure.bombs() < 99 && difficulty >= 80.0 && {can_leech}\n#needs_health adventure.playerHealth() < 99 && {can_leech}\n#needs_mana adventure.mana() < 99 && adventure.hasItem(\"manaReaver\") && {can_cast}\n#needs_keys adventure.keys() <= 10\n\n#any_needs {needs_bombs} || {needs_health} || {needs_mana} || {needs_keys}\n\n#num_enemies round(difficulty * 0.1 + 3.0)\n#elite_dmg d2i(floor(difficulty * 0.01 + 1.0)) * (\\\n  d2i(ceil(ceil(difficulty * 0.39) * 1.5)) - adventure.playerArmor()\\\n)\n\ngoto(start)\n\nnext:\n; partity is in charge of making sure we never exit farm keys until\n; we're back in the room we started in\nparity = not(parity)\nadventure.move({nextDir(dir)})\n; dir always has a valid exit when we enter next:\n\nstart:\ndifficulty = {cur_difficulty(0.0)}\nneeds_something = {survivable(difficulty)} && ({any_needs})\ndir = sub(\\\n  \"XU   D  L  R\", \\\n  index(\" 918 90 09 189\", x(adventure.playerPos()) . y(adventure.playerPos()), 0), \\\n  1\\\n)\nskipped = contains(\"UDLR\", dir) && (\\\n  (adventure.countEntities(\"Elite\") > 0) != (needs_something && {needs_bombs})\\\n    && (\\\n      adventure.countEntities(\"Elite\") > 0 || \\\n      adventure.playerHealth() > 100 - d2i({num_enemies} * 1.8)\\\n    )\\\n    || (adventure.countEntities(\"Elite\") > 0 && adventure.playerHealth() <= {elite_dmg})\\\n    || (parity && not(needs_something))\\\n)\n; Need to protect against arcade being closed during the loop, because\n; executesync will stall forever in that case due to the script condition\nexecutesync(if(\\\n  skipped || not(isopen(\"arcade\")),\\\n  \"{package}:xNOOPx\",\\\n  \"{package}:kill enemies\"\\\n))\n; Update needs_something after clearing\ngoto(if(\\\n  contains(\"UDLR\", dir) && leon.adventure.running && \\\n    (needs_something && ({any_needs}) || parity || skipped),\\\n  next,\\\n  end\\\n))\nend:\nwait(0.0)\n"],["find loot",":import adventure_lib\n:name {package}:find loot\n\n:budget_cap 101\n; using 101 so that the first executesync() doesn't\n; use up all our budget when executed by init\n\n:global int leon.adventure.maxDifficulty\n:global bool leon.adventure.running\n:global string leon.adventure.path\n:global string leon.adventure.room_direction\n\n:local string market_data\n\nkey.{up}()\nkey.{down}()\n\nisopen(\"arcade\")\n\n; Initialize variables so that pressing \"u\" or \"j\" after resetting AI\n; doesn't increment from 0\nexecutesync(if(\\\n  contains(impulse(), \"key.\"),\\\n  \"{package}:init\",\\\n  \"{package}:xNOOPx\"\\\n))\nleon.adventure.maxDifficulty = if(\\\n  {contains.key({down})}, \\\n  leon.adventure.maxDifficulty - 1, \\\n  if({contains.key({up})}, leon.adventure.maxDifficulty + 1, leon.adventure.maxDifficulty)\\\n)\ngotoif(end, contains(impulse(), \"key.\"))\n\n; Buy the first market item in our priority list that we don't have.\n; We don't need to worry about checking for the market or available emeralds;\n; if we can't buy the item, we'll simply fail to purchase and continue on.\n\n; This Lua macro constructs a data table that is used to iterate over the items\n; efficiently. The encoding is length-2 size, length-3 position, and\n; variable-length data. The size and position are for locating the *next* item.\n#data_table {lua(\\\n  local acc = {};\\\n  local items = table.pack(\\\n    \"impaler\", \"hammer\", \"bootsPhasing\", \"leechSword\", \"manaReaver\", \\\n    \"eodArmor\", \"thornsArmor\", \"holyBomb\", \"bookSpells\"\\\n  );\\\n  local i = 3\\\n  for j, item in ipairs(items) do\\\n\t  acc[i] = item;\\\n  \ti = i + 3\\\n  end\\\n  i = 3\\\n  pos = 0\\\n  while acc[i] do\\\n    pos = pos + 5 + #acc[i]\\\n    acc[i-2] = string.format(\"%02d\", #(acc[i+3] or \"\") + 5)\\\n    acc[i-1] = string.format(\"%03d\", pos)\\\n    i = i + 3\\\n  end\\\n  return table.concat(acc)\\\n)}\n\nmarket_loop:\nmarket_data = sub(\\\n  \"{data_table}\",\\\n  s2i(sub(market_data, 2, 3), 0),\\\n  s2i(sub(market_data, 0, 2), 12)\\\n)\n; Loop until we find an unbought item. By the nature of hasItem, it will\n; always return false for the empty string at the end of the loop, so we\n; don't need an explicit end check.\ngotoif(market_loop, adventure.hasItem(sub(market_data, 5, 99)))\nadventure.buyMarketItem(sub(market_data, 5, 99))\n\n; Turn our room direction into a target exit via lookup-table.\nglobal.string.set({target_pos_var}, sub(\\\n  \"0918 0009 1809 0900\",\\\n  index(\"U    L    R    D\", leon.adventure.room_direction, 0),\\\n  4\\\n) . \":\")\n\nexecutesync(\"{package}:analyze loot\")\nloop:\nexecutesync(\"{package}:find path\")\nexecutesync(\"{package}:follow path\")\nglobal.string.set({target_pos_var}, sub({target_positions}, 5, 99999))\ngotoif(loop, len({target_positions}) > 0 && leon.adventure.running)\n\nadventure.move({nextDir(leon.adventure.room_direction)})\nend:\nwait(0.)\n"],["find path",":import adventure_lib\n:name {package}:find path\n\n:budget_cap 1\n\n:global string leon.adventure.path\n\n:local vector curPos\n:local string queue\n:local string idx\n:local string dir\n:local string path\n:local bool cantPhase\n\n#setField(index, value) lss(\"_f\" . {index}, {value})\n#getField(index) lsg(\"_f\" . {index})\n\nleon.adventure.path = \"\"\ncantPhase = not(adventure.hasItem(\"bootsPhasing\"))\\\n|| 0 < max(\\\n  max(\\\n    adventure.countEntities(\"Chest\"),\\\n    adventure.countEntities(\"Enemy\")\\\n  ),\\\n  adventure.countEntities(\"Elite\")\\\n)\nqueue = {vecToString(adventure.playerPos())} . \"S:\"\n\nloop1:\ncurPos = {firstElementPos}\nidx = sub(queue, 0, 4)\n{setField(if({getField(idx)} != \"\", \"\", idx), {firstElementDir})}\nqueue = if(\\\n  {getField(idx)} != {firstElementDir},\\\n  sub(queue, 6, 99999),\\\n  sub(queue, 6, 99999) . if(\\\n    adventure.isWall(curPos + vec(0.0, 1.0)) && cantPhase\\\n      || max(x(curPos), y(curPos)) >= 18.0\\\n      || x(curPos) < 1.0,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) + 1.0)} . \"U:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(0.0, -1.0)) && cantPhase\\\n      || min(x(curPos), y(curPos)) < 1.0\\\n      || x(curPos) >= 18.0,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) - 1.0)} . \"D:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(1.0, 0.0)) && cantPhase\\\n      || max(x(curPos), y(curPos)) >= 18.0\\\n      || y(curPos) < 1.0,\\\n    \"\",\\\n    {posToString(x(curPos) + 1.0, y(curPos))} . \"R:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(-1.0, 0.0)) && cantPhase\\\n      || min(x(curPos), y(curPos)) < 1.0\\\n      || y(curPos) >= 18.0,\\\n    \"\",\\\n    {posToString(x(curPos) - 1.0, y(curPos))} . \"L:\"\\\n  )\\\n)\ngoto(if(\\\n  contains(\"\", queue) || contains(idx, sub({target_positions}, 0, 4)),\\\n  l2start,\\\n  loop1\\\n))\n\nloop2:\nleon.adventure.path = dir . leon.adventure.path\ncurPos = curPos - {nextDir(dir)}\nidx = {vecToString(curPos)}\n\nl2start:\ndir = {getField(idx)}\ngotoif(loop2, dir != \"S\")\n\nexecutesync(\"{package}:refine path\")\nwait(0.0)\n"],["follow path",":import adventure_lib\n:name {package}:follow path\n\n:budget_cap max\n\n:global bool leon.adventure.running\n:global string leon.adventure.path\n\n:local int stepCount\n:local vector curPos\n:local bool waitChest\n:local vector nextMove\n\n#nextDirection sub(leon.adventure.path, stepCount, 1)\n#nextMove {nextDir({nextDirection})}\n#curEntity adventure.entityType(curPos + {nextDir({nextDirection})})\n\ngoto(if(\\\n  isopen(\"arcade\") && leon.adventure.running,\\\n  start,\\\n  end\\\n))\n\nbomb:\nadventure.placeBomb()\ngoto(move)\n\nwait:\nadventure.wait()\n\nmove:\nstepCount = stepCount + 1\n\nstart:\ncurPos = adventure.playerPos()\nnextMove = {nextMove}\nwaitChest = contains(adventure.entityType(adventure.playerPos() + nextMove), \"Chest\")\n\nmove2:\nwaitframe()\nadventure.move(nextMove)  ; This is a no-op for invalid (0,0) moves\n\nloop:\n; This uses the spacing of unused values in the index expression to be equivalent\n; to lines to skip *backward*. This is much cheaper than having a nested ternary.\n; index returns -1 for the fallthrough case. (UDLR -> move)\ngoto(if(\\\n  stepCount < len(leon.adventure.path) && leon.adventure.running && isopen(\"arcade\"),\\\n  if(\\\n    contains(\"BW\", {nextDirection})\\\n      || x(curPos) != x(adventure.playerPos())\\\n      || y(curPos) != y(adventure.playerPos())\\\n      || waitChest && contains(\"\", adventure.entityType(adventure.playerPos() + nextMove)),\\\n    wait - index(\"W B\", {nextDirection}, 0),\\\n    move2\\\n  ),\\\n  end\\\n))\n\nend:\nwait(0.)\n"],["kill enemies",":import adventure_lib\n:name {package}:kill enemies\n\n:budget_cap max\n\n:global bool leon.adventure.running\n\nkey.{kill}()\n\nisopen(\"arcade\")\n\n#enemyCount adventure.countEntities(\"Enemy\")\n#eliteCount adventure.countEntities(\"Elite\")\n\n; Import Editor_actions lib to create editor actions in lua\n:import Editor_actions lib\n{lua(\\\n  local playerPos = \"adventure.playerPos()\";\\\n  local function enemyInDir(offset)\\\n    --[[Function that checks if a tile has an enemy in relation to the player position]]\\\n    local position = editor_math(playerPos, \"+\", offset);\\\n    return editor_adventureIsEnemy(position);\\\n  end\\\n  \\\n  function enemyDirection()\\\n    local offset = {};\\\n    offset[1] = editor_vec(0.0, 1.0);\\\n    offset[2] = editor_vec(1.0, 0.0);\\\n    offset[3] = editor_vec(0.0, -1.0);\\\n    offset[4] = editor_vec(-1.0, 0.0);\\\n    --[[/*\\\n        * List of offsets\\\n        * Function checks if an enemy is in x direction\\\n        * if it is, return the offset, otherwise, check the next offset\\\n        * \\\n        * returns vec(0.0, 0.0) if no enemies are arround\\\n       */]]\\\n    local function construct_enemyDirection(index, rest)\\\n      if index == 4 then\\\n        return rest;\\\n      end\\\n      index = index + 1;\\\n      local direction = offset[index];\\\n      local condition = enemyInDir(direction);\\\n      local false_case = construct_enemyDirection(index, rest);\\\n      return editor_if(condition, direction, false_case);\\\n    end\\\n    return construct_enemyDirection(0, editor_vec(0.0, 0.0));\\\n  end\\\n  function anyEnemies()\\\n    --[[/*\\\n        * Checks if there's any enemies \\\n        * in the 4 directions surround the player\\\n       */]]\\\n    local offset = {};\\\n    offset[1] = editor_vec(0.0, 1.0);\\\n    offset[2] = editor_vec(0.0, -1.0);\\\n    offset[3] = editor_vec(1.0, 0.0);\\\n    offset[4] = editor_vec(-1.0, 0.0);\\\n    local function construct_anyEnemies(index)\\\n      index = index + 1;\\\n      if index == 4 then\\\n        return enemyInDir(offset[4]);\\\n      end\\\n      local enemy = enemyInDir(offset[index]);\\\n      return editor_math(enemy, \"||\", construct_anyEnemies(index));\\\n    end\\\n    return construct_anyEnemies(0);\\\n  end\\\n)}\n\n#enemyDirection {lua(return enemyDirection())}\n#anyEnemies {lua(return anyEnemies())}\n\n; Initialize variables so that pressing \"k\" after resetting AI\n; toggles leon.adventure.running. We're using plain execute here\n; because we want the launching script to continue and die while\n; the copy of init we execute will keep running, and eventually\n; launch another copy of \"kill enemies\".\n; This architecture, although roundabout, keeps the starting and\n; stopping of turbo in a single place (init) and thus ultimately\n; is simpler.\nexecute(if(\\\n  contains(impulse(), \"key.\"),\\\n  \"{package}:init\",\\\n  \"{package}:xNOOPx\"\\\n))\ngoto(if(contains(impulse(), \"key.\"), end, loop))\n\nwait:\nadventure.wait()\n\nattack:\nwaitframe()\nadventure.move({enemyDirection})\n\nloop:\ngotoif(\\\n  if({anyEnemies}, attack, wait),\\\n  leon.adventure.running && 0 < max({enemyCount}, {eliteCount})\\\n)\nend:\n"],["refine path",":import adventure_lib\n:name {package}:refine path\n\n:budget_cap max\n\n:global string leon.adventure.path\n\n:local vector curPos\n:local int stepCount\n\n#has_hammer adventure.hasItem(\"hammer\")\n\n#curDirection sub(leon.adventure.path, stepCount, 1)\n#insert(st,i,val) sub({st},0,{i}) . ({val}) . sub({st},{i},99999)\n#escapeDirection if(\\\n  adventure.entityType(curPos + vec(0., 1.)) == \"\"\\\n    && adventure.entityType(curPos + vec(0., 2.)) == \"\"\\\n    && false == adventure.isWall(curPos + vec(0., 1.))\\\n    && y(curPos) < 17.,\\\n  \"BUUWDD\",\\\n  if(\\\n    adventure.entityType(curPos + vec(0., -1.)) == \"\"\\\n      && adventure.entityType(curPos + vec(0., -2.)) == \"\"\\\n      && false == adventure.isWall(curPos + vec(0., -1.))\\\n      && y(curPos) > 1.,\\\n    \"BDDWUU\",\\\n    if(\\\n      adventure.entityType(curPos + vec(-1., 0.)) == \"\"\\\n        && adventure.entityType(curPos + vec(-2., 0.)) == \"\"\\\n        && false == adventure.isWall(curPos + vec(-1., 0.))\\\n        && x(curPos) > 1.,\\\n      \"BLLWRR\",\\\n      \"BRRWLL\"\\\n    )\\\n  )\\\n)\n\ncurPos = adventure.playerPos()\ngoto(start)\n\nrock:\nleon.adventure.path = {insert(\\\n  leon.adventure.path,\\\n  stepCount,\\\n  if(adventure.hasItem(\"eodArmor\"), \"BWWW\", {escapeDirection})\\\n)}\nstepCount = stepCount + if(adventure.hasItem(\"eodArmor\"), 4, 6)\n\nnextTile:\ncurPos = curPos + {nextDir({curDirection})}\nstepCount = stepCount + 1\n\nstart:\ngoto(if(\\\n  stepCount >= len(leon.adventure.path),\\\n  end,\\\n  if(\\\n    adventure.entityType(curPos + {nextDir({curDirection})}) != \"Rock\" || {has_hammer},\\\n    nextTile,\\\n    rock\\\n  )\\\n))\nend:\n"],["adventure_lib","#package Adventure v3.3.5\n\n; key assignment macros\n#start r\n#reinit i\n; \n#up u\n#down j\n; \n#kill k\n\n; Detect which impulse the script was triggered by\n#contains.key(key) contains(impulse(), \"key.{key}\")\n\n; The name of the variable that stores \"target positions\" state.\n; Doubles as the start of the variable-hiding block.\n#target_pos_var \"<size=0>adv.target_pos\"\n#target_positions global.string.get({target_pos_var})\n\n; Convert a vector that has been pre-split into its two components into\n; stringified form. This only works for non-negative numbers.\n#posToString(x, y) sub(d2s(({x}) + 200.), 1, 2) . sub(d2s(({y}) + 200.), 1, 2)\n\n; Split a vector into its 2 components to be processed by posToString\n#vecToString(vector) {posToString(x({vector}), y({vector}))}\n\n; Convert a length-4 stringified vector to vector form.\n; This evaluates str twice, so that should be a small expression.\n; This *will* work with negative values, if they're small enough.\n#strToVec(str) vec(s2d(sub({str}, 0, 2), -1.), s2d(sub({str}, 2, 2), -1.))\n\n; Macros for working with BFS queues. The queue is structured as a\n; length-4 stringified position followed by a length-1 direction.\n#firstElementPos {strToVec(queue)}\n#firstElementDir sub(queue, 4, 1)\n\n; Calculate the difficulty of the room the player is in.\n; This formulation is a bit harder to follow than the traditional one\n; that uses absolute values, but it require fewer operations.\n;\n; This takes a parameter \"offset\", which is added to the difficulty.\n; This exists because it can be constant-folded in to this calculation,\n; whereas if we add it later it's a separate addition.\n#cur_difficulty(offset) (\\\n  max(\\\n    254. - x(adventure.roomCoords()),\\\n    x(adventure.roomCoords())\\\n  ) + max(\\\n    254. - y(adventure.roomCoords()),\\\n    y(adventure.roomCoords())\\\n  ) + ({offset} - 254.)\\\n)\n\n; Calculate if the given difficulty (i.e. distance) is \"survivable\",\n; i.e. can be cleared automatically without taking damage. This includes\n; comparing against maxDifficulty, which technically doesn't affect your\n; ability to survive, but does determine how the AI chooses rooms.\n#survivable(difficulty) (\\\n  ceil(i2d(adventure.playerAttack()) * if(adventure.hasItem(\"impaler\"), 1.1, 1.)) >=\\\n    round({difficulty} * 0.38 + 1.) + round({difficulty} * 0.08)\\\n    || i2d(adventure.playerArmor()) >= ceil({difficulty} * 0.39)\\\n) && i2d(leon.adventure.maxDifficulty) >= {difficulty}\\\n  && (adventure.hasItem(\"lantern\") || {difficulty} < 100.)\n\n; Convert a U/D/R/L direction into a direction vector by using index\n; and lookup tables. These are arranged so that if the lookup fails\n; (i.e. if the direction is \"W\" for wait), the s2d will default to (0.,0.).\n#nextX(d) s2d(sub(\"X 0 0 1-1\", index(\" U D R L\", {d}, 0), 2), 0.)\n#nextY(d) s2d(sub(\"X 1-1 0 0\", index(\" U D R L\", {d}, 0), 2), 0.)\n#nextDir(d) vec({nextX({d})}, {nextY({d})})\n"]]}}
```

### v3.3.5

Added key assignment macros in adventure_lib.<br>
Cleaned up a little bit of the logic with `not()`, `contains()` and macros.<br>
Added Editor_actions lib dependency for [kill enemies](kill%20enemies.tpt2).<br>
Added some more comments in hopes to understand the script better.

### V3.3.1

Replaced turbo implementation with budget system.<br>
Init now corelates with the workspace contents.<br>

### V3.3

Bugfixes, market buying, and size reduction.

New feature: Auto-buys items from the emerald market. If you don't like the
order it buys things in, tough. It's optimized for improving the speed of the
AI, and it will buy all the items relatively quickly.

Because of auto-buying, the AI will now reach the default maxDifficulty on its
own without cheat armor or player intervention.

Fix: Buying the mana sword before the spellbook no longer puts the AI in a room-loop.

Fix: Handling of impulses is greatly improved. It should be impossible to get
into weird states by pressing keys rapidly now. You can press either "R" or "K"
to cancel the AI when it's running, and it will always stop what it's doing.

Fix: Make leaving the Arcade properly shutdown in all cases.

Eliminated a script via code combining.

```
Bundle size: 8636 (51531 uncompressed)   Scripts: 8   Max lines: 17
```

### V3.2

Efficient bomb/health/mana grinding.

Grinding only happens when you have the appropriate items for it (leech and/or mana sword).
When grinding bombs, rooms will be skipped if they don't contain elites. The
time ends up dominated by how much health you lose, so grinding at either d80
or d100 is best.

```
Bundle size: 49192   Scripts: 9   Max lines: 17
```

### V3.1

Major bugfixes. Major size reduction.

Basic mimic handling, although it takes 2x as much damage as it needs to.

Boots of Phasing are used, Voidforged Impaler effect is accounted for in
determining maximum distance.

```
Bundle size: 43160   Scripts: 9   Max lines: 17
```

### V3.0

First release under new management!

Checks relics for EODArmor instead of assuming you have it at distance 50, and
uses hammer when possible instead of bombing all rocks.

Significantly smaller.

```
Bundle size: 98476   Scripts: 9   Max lines: 17
```

### V2.0.1

Last version by xWar131x.

```
Bundle size: 138196  Scripts: 9   Max lines: 18
```
