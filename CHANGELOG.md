## Version History

### Workspace Import

Use this if you want a copy of the source for modifying in the editor.
```
{"workspaces":{"Adventure":[["init",":import adventure_lib\n:name {package(init)}\n\n:budget_cap max\n; minimum budget cap is 200, but because key.{kill} lets us buy\n; \n; minimum budget cap so that init can quit in 1 frame\n\n;\n:local bool parity\n:local bool needs_something\n:local bool skipped\n\n; \n:local double maxDifficultyInit\n:local double difficulty\n; \n\n;\n:local string market_data\n:local string exit_dir\n:local string dir\n;\n:local vector curPos\n\n\nkey.{reinit}()\n; reinitialize maxDifficulty\n; \nkey.{start}()\n; Toggle the script state\n; \nkey.{up}()\nkey.{down}()\n; Increment/Decrement maxDifficulty by 1\n; \nkey.{kill}()\n; Shut down the AI and enters farm keys to\n; top us off, then, it terminates the program\n\nisopen(\"arcade\")\n\n\n; Square pattern\n; RULDRU\n; pos = if(\\\n  x(adventure.playerCoords()) == if(pos % 4 >= 2, 127 - i, 127 + i) &&\\\n  y(adventure.playerCoords()) == if(\\\n    pos > 2, \\\n    min(127 + i, 127 + i * (pos % 5)), \\\n    max(127 - i, 127 - i * (pos % 5))\\\n  ), \\\n  (pos + 1) % 6, \\\n  pos\\\n)\n; direction = sub(\"RULD\", pos % 4, 1)\n\n\n; diamond pattern\n; Player spawns in the middle of the map at 127.0, 127.0\n; going R = x + 1.0\n; going U = y + 1.0\n; going L = x - 1.0\n; going D = y - 1.0\n#nextRoomLower if(\\\n  x(adventure.roomCoords()) < 127.0 && \\\n  y(adventure.roomCoords()) >= 127.0,\\\n  \"R\",\\\n  if(\\\n    x(adventure.roomCoords()) >= 127.0 && \\\n    y(adventure.roomCoords()) > 127.0,\\\n    \"D\",\\\n    if(\\\n      x(adventure.roomCoords()) > 127.0 && \\\n      y(adventure.roomCoords()) <= 127.0,\\\n      \"L\",\\\n      \"U\" \\\n    )\\\n  )\\\n)\n#rotateLeft(x) sub(\"LDRU\", index(\"ULDR\", {x}, 0), 1)\n; Conditionally rotate the direction \"x\" to the left.\n; The benefit of this macro is that it only expands \"x\" once.\n#condRotateLeft(cond, x) sub(\\\n  if({cond}, \"LDRU\", \"ULDR\"), \\\n  index(\"ULDR\", {x}, 0), \\\n  1\\\n)\n\n#count.entities(entity) adventure.countEntities(\"{entity}\")\n; helper macro to shorten the process for counting entities\n\n; ======== Start init code ==============\n\n; This exists as a local variable solely to provide users\n; an easy place to customize it, after it's been imported.\nmaxDifficultyInit = 81.0\n\n; can replace previous init with this to imitate a full completion\n;maxDifficultyInit = {cur_difficulty(1.0)}\n\n; Initialize all our global variables.\n; \n; Store our target positions.\n; It starts a hiding block ended when setting maxDiff\n{target.setPos({target.getPositions})}\n\n; \n; Change the state of the script.\n; If we use key.{kill}, our state must be off, otherwise\n; try to toggle our state.\n{state.set(\\\n  impulse() != \"key.{kill}\" && \\\n  {state.get} != (impulse() == \"key.{start}\")\\\n)}\n\n; hide the path\n; Overwrite its value if we're shut down\n{path.set(if({state.get}, {path.get}, \"\"))}\n\n; \n; Make sure that maxDifficulty is at least 2.\n; if it's 1 it gets stuck in an endless loop\n; in the starting room for some reason\n; \n; Additionally, end the hiding block started by target_pos_var\n{maxDiff.set(if(\\\n  {maxDiff.get} < 2.0 || impulse() == \"key.{reinit}\",\\\n  max(2.0, maxDifficultyInit),\\\n  if(\\\n    contains(\"key.{start}|key.{kill}\", impulse()),\\\n    {maxDiff.get},\\\n    if(\\\n      impulse() == \"key.{up}\", \\\n      {maxDiff.get} + 1.0,\\\n      max(2.0, {maxDiff.get} - 1.0)\\\n    )\\\n  )\\\n))}\n\ngoto(if(\\\n  impulse() == \"key.{kill}\" ||\\\n  impulse() == \"key.{start}\" && {state.get}, \\\n  start, \\\n  end\\\n))\n\n; ======== Continuous loop code ==============\n\n\n#can_leech adventure.hasItem(\"leechSword\")\n#can_cast adventure.hasItem(\"bookSpells\")\n#has_reaver adventure.hasItem(\"manaReaver\")\n\n#needs_bombs adventure.bombs() < 99 && difficulty >= 80.0 && {can_leech}\n#needs_health adventure.playerHealth() < 99 && {can_leech}\n#needs_armor adventure.manaArmor() < adventure.playerArmor() && {can_cast}\n#needs_mana adventure.mana() < 99 && {has_reaver} && {can_cast}\n#needs_keys adventure.keys() <= 10\n\n#any_needs {needs_bombs} || {needs_health} || {needs_mana} || {needs_keys}\n\n#num_enemies round(difficulty * 0.1 + 3.0)\n\n; calculate how much health an elite has\n#elite_health d2i(floor(difficulty * 0.01 + 1.0))\n; \n; calculate how much damage an elite deals\n#elite_dmg d2i(ceil(ceil(difficulty * 0.39) * 1.5))\n; \n; calculate how much damage an elite will actually deal to us\n#elite_trueDMG {elite_health} * ({elite_dmg} - adventure.playerArmor())\n\n#player_health adventure.playerHealth() + adventure.manaArmor()\n\nnext:\n; partity is in charge of making sure we never exit farm keys until\n; we're back in the room we started in\nparity = not(parity)\n\n{path.set(exit_dir)}\nexecutesync(\"{package(follow path)}\")\n\nstart:\ndifficulty = {cur_difficulty(0.0)}\n\ngotoif(skip_mana, {needs_bombs})\nmana_loop:\nadventure.useSpell(\"manaArmor\")\ngotoif(mana_loop, {needs_armor} && adventure.mana() >= 5)\nskip_mana:\n\nneeds_something = {survivable(difficulty)} && ({any_needs})\\\n  && adventure.playerHealth() > 0\n\n; \" U   L   R   D   \" = \"X{dir_spaced(3)}\"\n; \" 918 09  189 90  \"\n:const string exit_coord \" 918 09  189 90  \"\n#exit_concat x(adventure.playerPos()) . y(adventure.playerPos())\nexit_dir = sub(\"X{dir_spaced(3)}\", index(exit_coord, {exit_concat}, 0), 1)\n; get our exit direction\n\n; We are skipped if we have a valid exit direction and:\n; - there are multiple elites while we don't need bombs and\n;   we can't clear the entire room with our hp\n; or\n; - there are more elites in the room and we won't survive killing all of them\n; or\n; - our needs are met but we're not in the same room we started in\nskipped = contains(\"ULRD\", exit_dir) && (\\\n  (adventure.countEntities(\"Elite\") > 0) != \\\n  (needs_something && {needs_bombs}) && (\\\n    adventure.countEntities(\"Elite\") > 0 || \\\n    {player_health} > 100 - d2i({num_enemies} * 1.8)\\\n  ) || (\\\n    adventure.countEntities(\"Elite\") > 0 && \\\n    {player_health} <= {elite_trueDMG}\\\n  ) || (parity && not(needs_something))\\\n)\n\ngoto(if(skipped, next, killer_loop))\n\n; Start of kill enemies\n\n#enemyInDir(x, y) adventure.isEnemy(adventure.playerPos() + vec({x},{y}))\n; Check if an enemy is in the inputed direction\n\n; Move in the enemies direction\n#enemyDirection if({enemyInDir(0.0, 1.0)}, vec(0.0, 1.0),\\\n                if({enemyInDir(1.0, 0.0)}, vec(1.0, 0.0),\\\n                if({enemyInDir(0.0,-1.0)}, vec(0.0,-1.0),\\\n                if({enemyInDir(-1.0, 0.0)}, vec(-1.0, 0.0), \\\n                vec(0.0, 0.0)))))\n\n; check if there are any enemies next to the player\n#anyEnemies {enemyInDir(0.0, 1.0)} || {enemyInDir( 0.0,-1.0)} ||\\\n            {enemyInDir(1.0, 0.0)} || {enemyInDir(-1.0, 0.0)}\n\nkiller_wait:\nadventure.wait()\n; wait in our curent position\n\nattack:\nwaitframe()\nadventure.move({enemyDirection})\n; move towards the enemy to attack it\n; wait frame is needed here to handle invalid (0, 0) movements\n\nkiller_loop:\ngoto(if(\\\n  isopen(\"arcade\") && {state.get} || impulse() == \"key.{kill}\",\\\n  if(\\\n    max({count.entities(Enemy)}, {count.entities(Elite)}) > 0,\\\n    if({anyEnemies}, attack, killer_wait),\\\n    if(\\\n      contains(\"ULRD\", exit_dir) &&\\\n        (parity || needs_something && ({any_needs})),\\\n      next,\\\n      if(impulse() == \"key.{kill}\", end, main_loop)\\\n    )\\\n  ),\\\n  end\\\n))\n\nmain_loop:\n; We check based on current difficulty plus 1,\n; because it's more efficient that way.\ndifficulty = {cur_difficulty(1.0)}\n\n; This line is responsible for maxDifficulty \"creeping\" upwards.\n; When used properly, it will cause the AI to slowly make spirals that cover\n; (nearly) the entire maze. However, extra lines can \"trick\" it and\n; cause it to jump more difficulty levels than wanted.\n;\n; Note the check against current difficulty\n; (which is current_difficulty + 1 here), which prevents this from\n; triggering multiple times before the AI can travel to new rooms.\n;\n; if the room isn't clear or we've just woken up, we don't change maxDiff\n; otherwise, if we can survive the next difficulty, we increment by 2, if not, we decrement by 2\n; \n{maxDiff.set({maxDiff.get} + if(\\\n  difficulty <= {maxDiff.get} || {count.entities(Chest)} > 0 || dir == \"\",\\\n  0.0,\\\n  if({survivable(difficulty)}, 2.0, -2.0)\\\n))}\n\ndir = if(\\\n  difficulty != 1.0 || dir == \"\",\\\n  {condRotateLeft({survivable(difficulty)}, {nextRoomLower})},\\\n  {rotateLeft(dir)}\\\n)\n\n; Buy the first market item in our priority list that we don't have.\n; We don't need to worry about checking for the market or\n; available emeralds if we can't buy the item, we'll simply fail\n; to purchase and continue on.\n\n; This Lua macro constructs a data table that is used to iterate over\n; the items efficiently. The encoding is length-2 size, length-3 position,\n; and variable-length data. The size and position are for locating the\n; *next* item.\n#data_table {lua(\\\n  local market = {};\\\n  local items = table.pack(\\\n    \"impaler\", \"hammer\", \"bootsPhasing\",\\\n    \"leechSword\", \"manaReaver\", \"thornsArmor\", \\\n    \"holyBomb\", \"eodArmor\", \"bookSpells\"\\\n  );\\\n  for item = 1, #items do\\\n    market[item * 3] = items[item];\\\n  end\\\n  local pos = 0;\\\n  for item = 1, #items do\\\n    local offset = item * 3;\\\n    pos = pos + 5 + #market[offset];\\\n    local next_item = #(market[offset + 3] or \"\");\\\n    market[offset - 2] = string.format(\"%02d\", 5 + next_item);\\\n    market[offset - 1] = string.format(\"%03d\", pos)\\\n  end\\\n  return table.concat(market)\\\n)}\n\nmarket_loop:\nmarket_data = sub(\\\n  \"{data_table}\",\\\n  s2i(sub(market_data, 2, 3), 0),\\\n  s2i(sub(market_data, 0, 2), 12)\\\n)\n\n; Loop until we find an unbought item. By the nature of hasItem, it will\n; always return false for the empty string at the end of the loop, so we\n; don't need an explicit end check.\ngoto(if(\\\n  isopen(\"arcade\") && {state.get},\\\n  if(adventure.hasItem(sub(market_data, 5, 99)), market_loop, buy),\\\n  end\\\n))\n\nbuy:\nadventure.buyMarketItem(sub(market_data, 5, 99))\n\n; Turn our room direction into a target exit via lookup-table.\n; \"XU    L    R    D    \" = \"X{dir_spaced(4)}\"\n; \" 0918 0009 1809 0900\"\n:const string exit_idx \" 0918 0009 1809 0900\"\n{target.setPos(sub(exit_idx, index(\"X{dir_spaced(4)}\", dir, 0), 4) . \":\")}\n\nexecutesync(\"{package(movement)}\")\n\n{path.set(dir)}\nexecutesync(\"{package(follow path)}\")\n\ngotoif(start, {state.get} && adventure.playerHealth() > 0)\n\nend:\n; We reach the end \n; \n; We're here if a filler action was used ({up}{down}{reinit}) or if we've shut down\n; {state.get} is false if the impulse was {kill} or {start} toggled us off\n; If the cause of the shut down was from an impulse, we don't need to change our state\n; However, if the player left adventure (exited arcade or entered another tab like lucky wheel),\n; then, we have to shut down, as we can no longer interact with adventure.\n; \n; \n{state.set({state.get} && adventure.playerHealth() > 0)}\n"],["movement",":import adventure_lib\n:name {package(movement)}\n\n:budget_cap 200\n\n:local bool cantPhase\n:local bool path_search\n; \n:local int stepCount\n; \n\n:local string dir\n:local string idx\n:local string queue\n:local string target\n:local string targetPos\n:local string lootPositions\n; \n:local vector curPos\n\n\n; There are 2 types of fields.\n; 1. The `analyze loot` field, which is used to\n;    detect where in the map loot can be found\n;    encoded as lss(\"f\" . index)\n; 2. The `find path` field, which is used\n;    to build the path to our target.\n;    encoded as lss(\"f\" . target . index)\n;    where target is the target position we're trying to reach\n\n\n#setField(index, target, field) lss(\"f\" . {target} . {index}, {field})\n#getField(index, target) lsg(\"f\" . {target} . {index})\n\n#setTPos(index, pos) lss(\"t\" . {index}, {pos})\n#getTPos(index) lsg(\"t\" . {index})\n\ncantPhase = not(adventure.hasItem(\"bootsPhasing\"))\\\n|| 0 < max(\\\n  max(\\\n    adventure.countEntities(\"Elite\"),\\\n    adventure.countEntities(\"Chest\")\\\n  ),\\\n  adventure.countEntities(\"Enemy\")\\\n)\n\nstepCount = 0\n; Reset stepCount\n\n; Set our target to empty if\n; cantPhase is true and path_search is false\n; otherwise, we get our first target position\n\ntarget = if(\\\n  not(cantPhase) || path_search,\\\n  sub({target.getPositions}, 0, 4),\\\n  \"\"\\\n)\n\nqueue = {vecToString(adventure.playerPos())} . \"S:\"\n\n; On the first entry of this loop, the junk entry \"_f\" will be set to \"S\".\n; This has no effect. In general, lootPositions, queue and setField are\n; protected so that if the field has already been set,\n; we won't take action again.\n\nloop1:\ncurPos = {firstElementPos}\nidx = sub(queue, 0, 4)\n\n; Add a position if it's not been processed and if it has a chest in it\n; this value is only relevant when we're analyzing loot, so the target\n; will always be an empty string\nlootPositions = if(\\\n  {getField(idx, \"\")} == \"\" && \\\n  adventure.entityType(curPos) == \"Chest\",\\\n  {vecToString(curPos)} . \":\" . lootPositions,\\\n  lootPositions\\\n)\n\n{setField(\\\n  if({getField(idx, target)} != \"\", \"\", idx), \\\n  target, \\\n  {firstElementDir}\\\n)}\n\n; If we've not added a position, pop the processed position\n; otherwise, pop the processed position and look at\n; the neighbouring 4 positions and\n; add all non-wall positions to the queue\nqueue = sub(queue, 6, 2^18) . if(\\\n  {getField(idx, target)} != {firstElementDir} || adventure.playerAttack() <= 0,\\\n  \"\",\\\n  if(\\\n    adventure.isWall(curPos + vec(0.0, 1.0)) && cantPhase\\\n    || max(x(curPos), y(curPos)) >= 18.0\\\n    || x(curPos) < 1.0,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) + 1.0)} . \"U:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(0., -1.0)) && cantPhase\\\n    || min(x(curPos), y(curPos)) < 1.0\\\n    || x(curPos) >= 18.0,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) - 1.0)} . \"D:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(1.0, 0.0)) && cantPhase\\\n    || max(x(curPos), y(curPos)) >= 18.0\\\n    || y(curPos) < 1.0,\\\n    \"\",\\\n    {posToString(x(curPos) + 1.0, y(curPos))} . \"R:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(-1.0, 0.0)) && cantPhase\\\n    || min(x(curPos), y(curPos)) < 1.0\\\n    || y(curPos) >= 18.0,\\\n    \"\",\\\n    {posToString(x(curPos) - 1.0, y(curPos))} . \"L:\"\\\n  )\\\n)\n\n; keep looping until we've encoded every tile we need\n; if we're here to calculate `find path`, we have to enter\n; l2start to start loop 2, otherwise, we continue over\n; to add our target positions\ngoto(if(\\\n  queue != \"\" && idx != target,\\\n  loop1,\\\n  if(not(cantPhase) || path_search, l2start, continue)\\\n))\n\ncontinue:\nlootPositions = {target.getPositions} . lootPositions\n; add the loot positions to our target positions\n\nloot_loop:\ntargetPos = sub(lootPositions, 0, 4)\n; get the next loot position\n\ncurPos = {strToVec(targetPos)}\n; set our curPos to our position\n\nlootPositions = sub(lootPositions, 5, 2^18)\n; pop the previous loot position\n\ninnerLoot_loop:\nidx = {vecToString(curPos)}\n; stringify our curPos to access our fields\n\n\n; insert our loot positions into our target_positions\n; \n; make our loot position the head if it can be accessed by our start and\n; it hasn't already been added to the target_positions\n; \n; otherwise, don't insert if the target position hasn't been recorded yet\n; or if it has already been inserted in our target_positions\n; \n; otherwise, insert a step to reach our loot position?\n#previous_pos curPos - {nextDir({getField(idx, \"\")})}\n; \n{target.setPos(if(\\\n  {getField({vecToString({previous_pos})}, \"\")} == \"S\" && \\\n  not(contains({target.getPositions}, targetPos)),\\\n  targetPos . \":\" . {target.getPositions},\\\n  if(\\\n    {getTPos(idx)} == \"\" || \\\n    contains({target.getPositions}, targetPos),\\\n    {target.getPositions},\\\n    sub(\\\n      {target.getPositions},\\\n      0,\\\n      index({target.getPositions}, {getTPos(idx)}, 0)\\\n    ) . targetPos . \":\" . sub(\\\n      {target.getPositions},\\\n      index({target.getPositions}, {getTPos(idx)}, 0),\\\n      2^18\\\n    )\\\n  )\\\n))}\n\n; set a target position if it hasn't been added to the target_positions\n; or overwrite the target position if its contents\n; is with target positions?\n{setTPos(idx, if(\\\n  {getTPos(idx)} != sub(\\\n    {target.getPositions},\\\n    index({target.getPositions}, targetPos, 0) + 5,\\\n    4\\\n  ) && contains({target.getPositions}, targetPos),\\\n  {getTPos(idx)},\\\n  targetPos\\\n))}\n\n; Update our curPos to the next tile\n; \n; We're actually working backwards, from the desired loot position back to\n; our starting position, so this \"next tile\" is a\n; tile closer to the player\n; \n\ncurPos = {previous_pos}\n; return to the innerLoop2 if we've not made\n; our way back to the starting position if we have,\n; move back to loop2 if there's more loot positions to add\n\ngoto(if(\\\n  {getField({vecToString(curPos)}, \"\")} != \"S\",\\\n  innerLoot_loop,\\\n  if(lootPositions != \"\", loot_loop, end)\\\n))\n\nloop2:\n{path.set(dir . {path.get})}\ncurPos -= {nextDir(dir)}\nidx = {vecToString(curPos)}\n\nl2start:\ndir = {getField(idx, target)}\ngoto(if(dir == \"S\", start, loop2))\n\n#has_hammer adventure.hasItem(\"hammer\")\n\n#curDirection sub({path.get}, stepCount, 1)\n#escapeDirection if(\\\n  adventure.entityType(curPos + vec(0.0, 1.0)) == \"\"\\\n    && adventure.entityType(curPos + vec(0.0, 2.0)) == \"\"\\\n    && not(adventure.isWall(curPos + vec(0.0, 1.0)))\\\n    && y(curPos) < 17.0,\\\n  \"BUUWDD\",\\\n  if(\\\n    adventure.entityType(curPos + vec(0.0, -1.0)) == \"\"\\\n      && adventure.entityType(curPos + vec(0.0, -2.0)) == \"\"\\\n      && not(adventure.isWall(curPos + vec(0.0, -1.0)))\\\n      && y(curPos) > 1.0,\\\n    \"BDDWUU\",\\\n    if(\\\n      adventure.entityType(curPos + vec(-1.0, 0.0)) == \"\"\\\n        && adventure.entityType(curPos + vec(-2.0, 0.0)) == \"\"\\\n        && not(adventure.isWall(curPos + vec(-1.0, 0.0)))\\\n        && x(curPos) > 1.0,\\\n      \"BLLWRR\",\\\n      \"BRRWLL\"\\\n    )\\\n  )\\\n)\n\nrock:\n{path.set(\\\n  sub({path.get}, 0, stepCount)\\\n  . if(adventure.hasItem(\"eodArmor\"), \"BWWW\", {escapeDirection})\\\n  . sub({path.get}, stepCount, 2 ^ 18)\\\n)}\n\nstepCount += if(adventure.hasItem(\"eodArmor\"), 4, 6)\n\nnextTile:\ncurPos = curPos + {nextDir({curDirection})}\nstepCount = stepCount + 1\n\n#move_dir adventure.entityType(curPos + {nextDir({curDirection})})\nstart:\ngoto(if(\\\n  isopen(\"arcade\") && {state.get},\\\n  if(\\\n    len({path.get}) <= stepCount,\\\n    start_following,\\\n    if({move_dir} != \"Rock\" || {has_hammer}, nextTile, rock)\\\n  ),\\\n  end\\\n))\n\nstart_following:\nexecutesync(\"{package(follow path)}\")\n\n{target.setPos(sub({target.getPositions}, 5, 2^18))}\n\nend:\npath_search = true\n; Set to true so we can reuse the top of the script\n; \n; keep looping until we no longer have any target positions\n; init will stop() us if the user leaves the bounds of our execution\ngotoif(0, {target.getPositions} != \"\" && {state.get} && adventure.playerHealth() > 0)\n"],["follow path",":import adventure_lib\n:name {package(follow path)}\n\n:budget_cap 200\n\n; Follow the formed path\n; This extra script is required because moving is fps dependent\n; If adventure.move() is used, it can fail to move you if your fps is too high\n\n; It's used by building a path through {path.set()} and then it eats it up\n; Script stops if you're no longer in adventure,\n; This is detected by checking if you've got 0 health\n\n:local bool waitChest\n;\n:local vector curPos\n:local vector nextMove\n\n#nextTile adventure.entityType(adventure.playerPos() + nextMove)\n\ngoto(start)\n\nbomb:\nadventure.placeBomb()\ngoto(move)\n\nwait:\nadventure.wait()\n\nmove:\n{path.set(sub({path.get}, 1, 2^18))}\n\nstart:\ncurPos = adventure.playerPos()\nnextMove = {nextDir(sub({path.get}, 0, 1))}\nwaitChest = {nextTile} == \"Chest\"\n\nmove2:\nwaitframe()\nadventure.move(nextMove)\n; this is a no-op for invalid (0,0) moves\n\n; Jump table that works because index() returns -1 if it can't find the desired character\n; index(\"AB\", \"C\", 0) = -1 because C is not in the string AB\n; \n; wait - index(\"W B\", sub(path, 0, 1), 0) is accessed if our next move is a bomb, wait or UDLR\n; If we're here with UDLR, we go to wait - -1 = wait + 1 = move:\n; If we're here with W, we go to wait - 0 = wait:\n; If we're here with B, we go to wait - 2 = bomb:\n; \n; We go to move2 if we've failed to do an UDLR movement\ngotoif(\\\n  if(\\\n    contains(\"WB\", sub({path.get}, 0, 1)) ||\\\n    waitChest && {nextTile} == \"\"\\\n    || x(curPos) != x(adventure.playerPos())\\\n    || y(curPos) != y(adventure.playerPos()),\\\n    wait - index(\"W B\", sub({path.get}, 0, 1), 0),\\\n    move2\\\n  ),\\\n  {state.get} && adventure.playerHealth() > 0 && {path.get} != \"\"\\\n)\n; This is the old and more space efficient version of\n; Though this one is worse, it can be used to better explain the instruction above\n;gotoif(\\\n;  if(\\\n;    sub({path.get}, 0, 1) == \"B\",\\\n;    bomb,\\\n;    if(\\\n;      sub({path.get}, 0, 1) == \"W\",\\\n;      wait,\\\n;      if(\\\n;        waitChest && {nextTile} == \"\"\\\n;        || x(curPos) != x(adventure.playerPos())\\\n;        || y(curPos) != y(adventure.playerPos()),\\\n;        move,\\\n;        move2\\\n;      )\\\n;    )\\\n;  ),\\\n;  adventure.playerHealth() > 0 && {path.get} != \"\"\\\n;)\n\n\n"],["adventure_lib","#package(name) Adventure v3.4.1:{name}\n\n; key assignment macros\n#start r\n#reinit i\n; \n#up u\n#down j\n; \n#kill k\n\n; lua macro that makes sure the export code doesn't have\n; duplicate impulse keys.\n{lua(\\\n  local impulse = {};\\\n  local keys = \"{start}|{reinit}|{up}|{down}|{kill}|\";\\\n  for word in keys:gmatch(\"[^|]+\") do\\\n    if impulse[word] ~= nil then\\\n     error(\"key. impulses can't have duplicates\", 0);\\\n    end\\\n    impulse[word] = 0;\\\n  end\\\n)}\n\n; \n; a string holding our direction sequence\n#dir_list \"ULRD\"\n\n; macro that returns a spaced out version of our dir_list\n; requires the ammount of spaces, a negative input\n; returns spaces before the direction\n; 01 => \"R \"\n; -1 => \" R\"\n#dir_spaced(space) {lua(\\\n  local directions = {};\\\n  local space = {space} < 0 and 1 - {space} or -1 - {space};\\\n  local spacer = \"%\" .. space .. \"s\";\\\n  for i = 1, #{dir_list} do\\\n    directions[i] = spacer:format(string.sub({dir_list}, i, i));\\\n  end\\\n  return table.concat(directions);\\\n)}\n\n; The name of the variable that stores \"target positions\" state.\n; Doubles as the start of the variable-hiding block.\n:const string target_pos_var \"<size=0>adv$target_pos@\"\n#target.getPositions global.string.get(target_pos_var)\n#target.setPos(position) global.string.set(target_pos_var, {position})\n\n; The state of the script.\n:const string state \"adv$running@\"\n#state.get global.bool.get(state)\n#state.set(value) global.bool.set(state, {value})\n\n; The path we follow to move through the room\n:const string path \"adv$path@\"\n#path.get global.string.get(path)\n#path.set(path) global.string.set(path, {path})\n\n; The maximum difficulty we can achieve\n:const string maxDiff \"</size>leon.adventure.maxDifficulty\"\n#maxDiff.get global.double.get(maxDiff)\n#maxDiff.set(difficulty) global.double.set(maxDiff, {difficulty})\n\n; Convert a coordinate into stringified form.\n#coordToString(coord) sub(d2s(200.0 + ({coord})), 1, 2)\n; Convert a vector that has been pre-split into its two components into\n; stringified form. This only works for non-negative numbers.\n#posToString(x, y) {coordToString({x})} . {coordToString({y})}\n\n; Split a vector into its 2 components to be processed by posToString\n#vecToString(vector) {posToString(x({vector}), y({vector}))}\n\n; Convert a string to a coordinate.\n#strToCoord(str, offset) s2d(sub({str}, {offset}, 2), -1.0)\n\n; Convert a length-4 stringified vector to vector form.\n; This evaluates str twice, so that should be a small expression.\n; This *will* work with negative values, if they're small enough.\n#strToVec(str) vec({strToCoord({str},0)}, {strToCoord({str},2)})\n\n; Macros for working with BFS queues. The queue is structured as a\n; length-4 stringified position followed by a length-1 direction.\n#firstElementPos {strToVec(queue)}\n#firstElementDir sub(queue, 4, 1)\n\n; Calculate the difficulty of the room the player is in.\n; This formulation is a bit harder to follow than the traditional one\n; that uses absolute values, but it require fewer operations.\n;\n; This takes a parameter \"offset\", which is added to the difficulty.\n; This exists because it can be constant-folded in to this calculation,\n; whereas if we add it later it's a separate addition.\n#cur_difficulty(offset) (\\\n  max(\\\n    254.0 - x(adventure.roomCoords()),\\\n    x(adventure.roomCoords())\\\n  ) + max(\\\n    254.0 - y(adventure.roomCoords()),\\\n    y(adventure.roomCoords())\\\n  ) + ({offset} - 254.0)\\\n)\n\n; Calculate if the given difficulty (i.e. distance) is \"survivable\",\n; i.e. can be cleared automatically without taking damage. This includes\n; comparing against maxDifficulty, which technically doesn't affect your\n; ability to survive, but does determine how the AI chooses rooms.\n#survivable(difficulty) (\\\n  {difficulty} < 100.0 || \\\n  adventure.hasItem(\"lantern\")\\\n) && {maxDiff.get} >= {difficulty} && (\\\n  i2d(adventure.playerArmor()) >= ceil({difficulty} * 0.39) || if(\\\n    adventure.hasItem(\"impaler\"), \\\n    ceil(i2d(adventure.playerAttack()) * 1.1),\\\n    i2d(adventure.playerAttack())\\\n  ) >= round({difficulty} * 0.38 + 1.0) + round({difficulty} * 0.08)\\\n)\n\n; Convert a U/D/R/L direction into a direction vector by using index\n; and lookup tables. These are arranged so that if the lookup fails\n; (i.e. if the direction is \"W\" for wait),\n; the s2d will default to (0.,0.).\n#nextX(d) s2d(sub(\"X 0 0 1-1\", index(\" U D R L\", {d}, 0), 2), 0.)\n#nextY(d) s2d(sub(\"X 1-1 0 0\", index(\" U D R L\", {d}, 0), 2), 0.)\n#nextDir(d) vec({nextX({d})}, {nextY({d})})\n"]]}}
```

### v3.4.1

Future note. DO NOT ADD A UI TO ADVENTURE AI.

Script will shut down immediately once you leave the adventure tab.<br>
Renamed all global variables, and they're now defined in macro form. See the scripts [library](adventure_lib.tpt2).<br>
Added [follow path](follow%20path.tpt2) back into the script because movement is more complex than I first gave it credit.

I dislike how the path is generated, so hopefully the next update reworks it.

Bug fixes!<br>
Farm keys segment can now see the bottom exit as a valid direction.<br>
Removed the movement counter added in `v3.4.0`.

### v3.4.0

Adventure AI will no longer farm for mana armor if macro `needs_bombs` is true.<br>
The script will now shut down if you leave the adventure tab for too long.

### v3.3.9

Added macro `needs_armor` that determines if we need mana armor.<br>
If we do, then we'll spend all our mana to top up our mana armor.

### v3.3.8

Turned the 4 scripts `analyze loot`, `find path`, `refine path` and `follow path` into the single script `movement`.<br>
Global variable `leon.adventure.path` is now the local value `path` that's modified only in scrit `movement`.<br>
Script package is now down to only 2 scripts. I do not believe it'd be wise to try and compact it any further.

### v3.3.7

Fixed the order of the contains in the state toggle. non_kill and impulse() were swapped in the contains.<br>
Changed the kill_enemies loop to be a goto(if()) instead of a gotoif().<br>
Added a lua macro that doesn't let the script compile if the impulse keys have duplicate. Can't have 2 different impulses have the same key.<br>
Macro `{target_positions}` is now called `{target.getPositions}`.<br>
Added `{target.setPos}` to set a target position.<br>
impulse `key.{kill}` now enters farm keys to get our resources up.<br>
Fixed broken logic. I made find path think that it could phase when it couldn't.

### v3.3.6

Added `dir_spaced` macro that takes a number `space` and adds space amount of `spaces` inbetween each of the direction letters.
`"{dir_spaced(4)}" = "U    L    R    D    "` and `"{dir_spaced(-4)}" = "    U    L    R    D"`

Made all impulses be inside of init.<br>
`key.{kill}` now always shuts off the AI.<br>
scripts `kill enemies`, `farm keys` and `find loot` are now completely inside of init.

### v3.3.5

Added key assignment macros in adventure_lib.<br>
Cleaned up a little bit of the logic with `not()`, `contains()` and macros.<br>
Added Editor_actions lib dependency for [kill enemies](kill%20enemies.tpt2).<br>
Added some more comments in hopes to understand the script better.

### V3.3.1

Replaced turbo implementation with budget system.<br>
Init now corelates with the workspace contents.<br>

### V3.3

Bugfixes, market buying, and size reduction.

New feature: Auto-buys items from the emerald market. If you don't like the
order it buys things in, tough. It's optimized for improving the speed of the
AI, and it will buy all the items relatively quickly.

Because of auto-buying, the AI will now reach the default maxDifficulty on its
own without cheat armor or player intervention.

Fix: Buying the mana sword before the spellbook no longer puts the AI in a room-loop.

Fix: Handling of impulses is greatly improved. It should be impossible to get
into weird states by pressing keys rapidly now. You can press either "R" or "K"
to cancel the AI when it's running, and it will always stop what it's doing.

Fix: Make leaving the Arcade properly shutdown in all cases.

Eliminated a script via code combining.

```
Bundle size: 8636 (51531 uncompressed)   Scripts: 8   Max lines: 17
```

### V3.2

Efficient bomb/health/mana grinding.

Grinding only happens when you have the appropriate items for it (leech and/or mana sword).
When grinding bombs, rooms will be skipped if they don't contain elites. The
time ends up dominated by how much health you lose, so grinding at either d80
or d100 is best.

```
Bundle size: 49192   Scripts: 9   Max lines: 17
```

### V3.1

Major bugfixes. Major size reduction.

Basic mimic handling, although it takes 2x as much damage as it needs to.

Boots of Phasing are used, Voidforged Impaler effect is accounted for in
determining maximum distance.

```
Bundle size: 43160   Scripts: 9   Max lines: 17
```

### V3.0

First release under new management!

Checks relics for EODArmor instead of assuming you have it at distance 50, and
uses hammer when possible instead of bombing all rocks.

Significantly smaller.

```
Bundle size: 98476   Scripts: 9   Max lines: 17
```

### V2.0.1

Last version by xWar131x.

```
Bundle size: 138196  Scripts: 9   Max lines: 18
```
