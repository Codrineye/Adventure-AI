## Version History

### Workspace Import

Use this if you want a copy of the source for modifying in the editor.
```
{"workspaces":{"Adventure":[["init",":import adventure_lib\n:name {package}:init\n\n:budget_cap 201\n; minimum budget cap so that init can quit in 1 frame\n\n:const string hide_block \"adv---Stop hiding---\"\n#hide_blocker global.string.get(hide_block)\n\n:global double leon.adventure.maxDifficulty\n:global string leon.adventure.path\n\n:local double maxDifficultyInit\n:local double difficulty\n:local double inc\n:local double pos\n; \n:local string market_data\n:local string farm_dir\n:local string dir\n; \n:local bool square_up\n\n:local bool parity\n:local bool needs_something\n:local bool skipped\n\nkey.{reinit}()\n; reinitialize maxDifficulty\n; \nkey.{start}()\n; Toggle the script state\n; \nkey.{up}()\nkey.{down}()\n; Increment/Decrement maxDifficulty by 1\n; \nkey.{kill}()\n; Shut down the AI and enters farm keys to\n; top us off, then, it terminates the program\n\nisopen(\"arcade\")\n\n; Square pattern\n; RULDRU\n; pos = if(\\\n  x(adventure.playerCoords()) == if(pos % 4 >= 2, 127 - i, 127 + i) &&\\\n  y(adventure.playerCoords()) == if(\\\n    pos > 2, \\\n    min(127 + i, 127 + i * (pos % 5)), \\\n    max(127 - i, 127 - i * (pos % 5))\\\n  ), \\\n  (pos + 1) % 6, \\\n  pos\\\n)\n; direction = sub(\"RULD\", pos % 4, 1)\n\n; diamond pattern\n; Player spawns in the middle of the map at 127.0, 127.0\n; going R = x + 1.0\n; going U = y + 1.0\n; going L = x - 1.0\n; going D = y - 1.0\n#nextRoomLower if(\\\n  x(adventure.roomCoords()) < 127.0 && \\\n  y(adventure.roomCoords()) >= 127.0,\\\n  \"R\",\\\n  if(\\\n    x(adventure.roomCoords()) >= 127.0 && \\\n    y(adventure.roomCoords()) > 127.0,\\\n    \"D\",\\\n    if(\\\n      x(adventure.roomCoords()) > 127.0 && \\\n      y(adventure.roomCoords()) <= 127.0,\\\n      \"L\",\\\n      \"U\" \\\n    )\\\n  )\\\n)\n#rotateLeft(x) sub(\"LDRU\", index(\"ULDR\", {x}, 0), 1)\n; Conditionally rotate the direction \"x\" to the left.\n; The benefit of this macro is that it only expands \"x\" once.\n#condRotateLeft(cond, x) sub(\\\n  if({cond}, \"LDRU\", \"ULDR\"), \\\n  index(\"ULDR\", {x}, 0), \\\n  1\\\n)\n\n#count.entities(entity) adventure.countEntities(\"{entity}\")\n; helper macro to shorten the process for counting entities\n\n; ======== Start init code ==============\n\n; This exists as a local variable solely to provide users\n; an easy place to customize it, after it's been imported.\nmaxDifficultyInit = 81.0\n\n; can replace previous init with this to imitate a full completion\n;maxDifficultyInit = {cur_difficulty(1.0)}\n\n; Initialize all our global variables.\n; Make sure that maxDifficulty is at least 2.\n; if it's 1 it gets stuck in an endless loop\n; in the starting room for some reason\nleon.adventure.maxDifficulty = if(\\\n  leon.adventure.maxDifficulty < 2.0 || impulse() == \"key.{reinit}\",\\\n  max(2.0, maxDifficultyInit),\\\n  if(\\\n    contains(\"key.{start}|key.{kill}\", impulse()),\\\n    leon.adventure.maxDifficulty,\\\n    if(\\\n      impulse() == \"key.{up}\", \\\n      leon.adventure.maxDifficulty + 1.0,\\\n      max(2.0, leon.adventure.maxDifficulty - 1.0)\\\n    )\\\n  )\\\n)\n\n; This variable also begins the variable hiding block with its name.\n{target.setPos({target.getPositions})}\n\n; \n; Change the state of the script.\n; If we use key.{kill}, our state must be off, otherwise, we\n; try to toggle our state.\n{state.set(\\\n  impulse() != \"key.{kill}\" && \\\n  {state.get} != (impulse() == \"key.{start}\")\\\n)}\n\nleon.adventure.path = leon.adventure.path\nglobal.string.set(hide_block, \"</size>\")\n\ngoto(if(\\\n  impulse() == \"key.{kill}\" || \\\n  impulse() == \"key.{start}\" && {state.get}, \\\n  start, \\\n  end\\\n))\n\n; ======== Continuous loop code ==============\n\n\n#can_leech adventure.hasItem(\"leechSword\")\n#can_cast adventure.hasItem(\"bookSpells\")\n#has_reaver adventure.hasItem(\"manaReaver\")\n\n#needs_bombs adventure.bombs() < 99 && difficulty >= 80.0 && {can_leech}\n#needs_health adventure.playerHealth() < 99 && {can_leech}\n#needs_mana adventure.mana() < 99 && {has_reaver} && {can_cast}\n#needs_keys adventure.keys() <= 10\n\n#any_needs {needs_bombs} || {needs_health} || {needs_mana} || {needs_keys}\n\n#num_enemies round(difficulty * 0.1 + 3.0)\n\n; calculate how much health an elite has\n#elite_health d2i(floor(difficulty * 0.01 + 1.0))\n; \n; calculate how much damage an elite deals\n#elite_dmg d2i(ceil(ceil(difficulty * 0.39) * 1.5))\n; \n; calculate how much damage an elite will actually deal to us\n#elite_trueDMG {elite_health} * ({elite_dmg} - adventure.playerArmor())\n\nnext:\n; partity is in charge of making sure we never exit farm keys until\n; we're back in the room we started in\nparity = not(parity)\nadventure.move({nextDir(farm_dir)})\n\nstart:\ndifficulty = {cur_difficulty(0.0)}\nneeds_something = {survivable(difficulty)} && ({any_needs})\n; \"XU   L   R   D\"   = \"X{dir_spaced(3)}\"\n; \" 918 09  189 09\"\n:const string exit_coord \" 918 09  189 09\"\n#exit_concat x(adventure.playerPos()) . y(adventure.playerPos())\nfarm_dir = sub(\"X{dir_spaced(3)}\", index(exit_coord, {exit_concat}, 0), 1)\n; get our exit direction\n\nskipped = contains(\"ULRD\", farm_dir) && (\\\n  (adventure.countEntities(\"Elite\") > 0) != \\\n  (needs_something && {needs_bombs}) && (\\\n    adventure.countEntities(\"Elite\") > 0 || \\\n    adventure.playerHealth() > 100 - d2i({num_enemies} * 1.8)\\\n  ) || (\\\n    adventure.countEntities(\"Elite\") > 0 && \\\n    adventure.playerHealth() <= {elite_trueDMG}\\\n  ) || (parity && not(needs_something))\\\n)\n\ngoto(if(skipped, next, killer_loop))\n\n; Start of kill enemies\n\n#enemyInDir(x, y) adventure.isEnemy(adventure.playerPos() + vec({x},{y}))\n; Check if an enemy is in the inputed direction\n\n; Move in the enemies direction\n#enemyDirection if({enemyInDir(0.0, 1.0)}, vec(0.0, 1.0),\\\n                if({enemyInDir(1.0, 0.0)}, vec(1.0, 0.0),\\\n                if({enemyInDir(0.0,-1.0)}, vec(0.0,-1.0),\\\n                if({enemyInDir(-1.0, 0.0)}, vec(-1.0, 0.0), \\\n                vec(0.0, 0.0)))))\n\n; check if there are any enemies next to the player\n#anyEnemies {enemyInDir(0.0, 1.0)} || {enemyInDir( 0.0,-1.0)} ||\\\n            {enemyInDir(1.0, 0.0)} || {enemyInDir(-1.0, 0.0)}\n\nkiller_wait:\nadventure.wait()\n; wait in our curent position\n\nattack:\nwaitframe()\nadventure.move({enemyDirection})\n; move towards the enemy to attack it\n; wait frame is needed here to handle invalid (0, 0) movements\n\nkiller_loop:\ngoto(if(\\\n  isopen(\"arcade\") && {state.get} || impulse() == \"key.{kill}\",\\\n  if(\\\n    max({count.entities(Enemy)}, {count.entities(Elite)}) > 0,\\\n    if({anyEnemies}, attack, killer_wait),\\\n    if(\\\n      contains(\"ULRD\", farm_dir) &&\\\n        (parity || needs_something && ({any_needs})),\\\n      next,\\\n      if(impulse() == \"key.{kill}\", end, main_loop)\\\n    )\\\n  ),\\\n  end\\\n))\n\nmain_loop:\n; We check based on current difficulty plus 1,\n; because it's more efficient that way.\ndifficulty = {cur_difficulty(1.0)}\n\n; This line is responsible for maxDifficulty \"creeping\" upwards. When used\n; properly, it will cause the AI to slowly make spirals that cover\n; (nearly) the entire maze. However, extra lines can \"trick\" it and\n; cause it to jump more difficulty levels than wanted.\n;\n; Note the check against current difficulty\n; (which is current_difficulty + 1 here), which prevents this from\n; triggering multiple times before the AI can travel to new rooms.\n;\n; We add 2 to maxDifficulty because adding 1 would cause us to overlap\n; prior progress, and we'd immediately add another 1 anyway.\nleon.adventure.maxDifficulty = if(\\\n  difficulty > leon.adventure.maxDifficulty \\\n    && {count.entities(Chest)} == 0,\\\n  leon.adventure.maxDifficulty + 2.0,\\\n  leon.adventure.maxDifficulty\\\n)\n\ndir = if(\\\n  difficulty != 1.0 || dir == \"\",\\\n  {condRotateLeft({survivable(difficulty)}, {nextRoomLower})},\\\n  {rotateLeft(dir)}\\\n)\n\n; Buy the first market item in our priority list that we don't have.\n; We don't need to worry about checking for the market or\n; available emeralds if we can't buy the item, we'll simply fail\n; to purchase and continue on.\n\n; This Lua macro constructs a data table that is used to iterate over\n; the items efficiently. The encoding is length-2 size, length-3 position,\n; and variable-length data. The size and position are for locating the\n; *next* item.\n#data_table {lua(\\\n  local market = {};\\\n  local items = table.pack(\\\n    \"impaler\", \"hammer\", \"bootsPhasing\",\\\n    \"leechSword\", \"manaReaver\", \"thornsArmor\", \\\n    \"holyBomb\", \"eodArmor\", \"bookSpells\"\\\n  );\\\n  for item = 1, #items do\\\n    market[item * 3] = items[item];\\\n  end\\\n  local pos = 0;\\\n  for item = 1, #items do\\\n    local offset = item * 3;\\\n    pos = pos + 5 + #market[offset];\\\n    local next_item = #(market[offset + 3] or \"\");\\\n    market[offset - 2] = string.format(\"%02d\", 5 + next_item);\\\n    market[offset - 1] = string.format(\"%03d\", pos)\\\n  end\\\n  return table.concat(market)\\\n)}\n\nmarket_loop:\nmarket_data = sub(\\\n  \"{data_table}\",\\\n  s2i(sub(market_data, 2, 3), 0),\\\n  s2i(sub(market_data, 0, 2), 12)\\\n)\n\n; Loop until we find an unbought item. By the nature of hasItem, it will\n; always return false for the empty string at the end of the loop, so we\n; don't need an explicit end check.\ngoto(if(\\\n  isopen(\"arcade\") && {state.get},\\\n  if(adventure.hasItem(sub(market_data, 5, 99)), market_loop, buy),\\\n  end\\\n))\n\nbuy:\nadventure.buyMarketItem(sub(market_data, 5, 99))\n\n; Turn our room direction into a target exit via lookup-table.\n; \"U    L    R    D    \" = \"{dir_spaced(4)}\"\n; \"0918 0009 1809 0900\"\n:const string exit_idx \"0918 0009 1809 0900\"\n{target.setPos(sub(exit_idx, index(\"{dir_spaced(4)}\", dir, 0), 4) . \":\")}\n; \n\nexecutesync(\"{package}:analyze loot\")\nfind_loot:\nexecutesync(\"{package}:find path\")\nexecutesync(\"{package}:follow path\")\n{target.setPos(sub({target.getPositions}, 5, 9999))}\n\n; keep looping until we no longer have any target positions\ngotoif(find_loot, {state.get} && {target.getPositions} != \"\")\n\nadventure.move({nextDir(dir)})\n\ngotoif(start, isopen(\"arcade\") && {state.get})\n\nend:\n; We reach the end \n\n; Our state is controlled by the top of the script, so we can\n; only reach here if {state.get} == false or if arcade is closed.\n; \n; If our state == false, we won't change anything,\n; as we're already shut down but if arcade is closed,\n; we must ensure that we shut down\n{state.set(isopen(\"arcade\") && {state.get})}\n"],["analyze loot",":import adventure_lib\n:name {package}:analyze loot\n\n:budget_cap max\n\n:local string queue\n:local string idx\n:local vector curPos\n:local string targetPos\n:local string lootPositions\n\n#setField(index, value) lss(\"_f\" . {index}, {value})\n#getField(index) lsg(\"_f\" . {index})\n; \n#setTPos(index, value) lss(\"_t\" . {index}, {value})\n#getTPos(index) lsg(\"_t\" . {index})\n\nqueue = {vecToString(adventure.playerPos())} . \"S:\"\n\n; On the first entry of this loop, the junk entry \"_f\" will be set to \"S\".\n; This has no effect. In general, lootPositions, queue and setField are\n; protected so that if the field has already been set,\n; we won't take action again.\nloop1:\ncurPos = {firstElementPos}\nidx = sub(queue, 0, 4)\n\n; Add a position if it's not been processed and if it has a chest in it\nlootPositions = if(\\\n  {getField(idx)} == \"\" && \\\n  adventure.entityType(curPos) == \"Chest\",\\\n  {vecToString(curPos)} . \":\" . lootPositions,\\\n  lootPositions\\\n)\n{setField(if({getField(idx)} != \"\", \"\", idx), {firstElementDir})}\n\n; If we've not added a position, pop the processed position\n; otherwise, pop the processed position and look at\n; the neighbouring 4 positions and\n; add all non-wall positions to the queue\nqueue = if(\\\n  {getField(idx)} != {firstElementDir},\\\n  sub(queue, 6, 99999),\\\n  sub(queue, 6, 99999) . if(\\\n    adventure.isWall(curPos + vec(0.0, 1.0)) || y(curPos) >= 18.0,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) + 1.0)} . \"U:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(0., -1.0)) || y(curPos) < 1.0,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) - 1.0)} . \"D:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(1., 0.0)) || x(curPos) >= 18.0,\\\n    \"\",\\\n    {posToString(x(curPos) + 1.0, y(curPos))} . \"R:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(-1.0, 0.)) || x(curPos) < 1.0,\\\n    \"\",\\\n    {posToString(x(curPos) - 1.0, y(curPos))} . \"L:\"\\\n  )\\\n)\n; Every position is ended with `:` so we should\n; repeat the loop until queue no longer has the character `:`\n; i.e until we've added a field for every tile in the room\ngotoif(loop1, queue != \"\")\n\ncontinue:\nlootPositions = {target.getPositions} . lootPositions\n; add the loot positions to our target positions\n\nloop2:\ntargetPos = sub(lootPositions, 0, 4)\n; get the next loot position\n\ncurPos = {strToVec(targetPos)}\n; set our curPos to our position\n\nlootPositions = sub(lootPositions, 5, 99999)\n; pop the previous loot position\n\ninnerLoop2:\nidx = {vecToString(curPos)}\n; stringify our curPos to access our fields\n\n\n; insert our loot positions into our target_positions\n; \n; make our loot position the head if it can be accessed by our start and\n; it hasn't already been added to the target_positions\n; \n; otherwise, don't insert if the target position hasn't been recorded yet\n; or if it has already been inserted in our target_positions\n; \n; otherwise, insert a step to reach our loot position?\n#next_vector curPos - {nextDir({getField(idx)})}\n{target.setPos(if(\\\n  {getField({vecToString({next_vector})})} == \"S\" && \\\n  not(contains({target.getPositions}, targetPos)),\\\n  targetPos . \":\" . {target.getPositions},\\\n  if(\\\n    {getTPos(idx)} == \"\" || \\\n    contains({target.getPositions}, targetPos),\\\n    {target.getPositions},\\\n    sub(\\\n      {target.getPositions},\\\n      0,\\\n      index({target.getPositions}, {getTPos(idx)}, 0)\\\n    ) . targetPos . \":\" . sub(\\\n      {target.getPositions},\\\n      index({target.getPositions}, {getTPos(idx)}, 0),\\\n      9999\\\n    )\\\n  )\\\n))}\n\n; set a target position if it hasn't been added to the target_positions\n; or overwrite the target position if its contents\n; is with target positions?\n{setTPos(idx, if(\\\n  {getTPos(idx)} != sub(\\\n    {target.getPositions},\\\n    index({target.getPositions}, targetPos, 0) + 5,\\\n    4\\\n  ) && contains({target.getPositions}, targetPos),\\\n  {getTPos(idx)},\\\n  targetPos\\\n))}\n\n; Update our curPos to the next tile\n; \n; We're actually working backwards, from the desired loot position back to\n; our starting position, so this \"next tile\" is a\n; tile closer to the player\n; \n\ncurPos -= {nextDir({getField(idx)})}\n; return to the innerLoop2 if we've not made\n; our way back to the starting position if we have,\n; move back to loop2 if there's more loot positions to add\ngoto(if(\\\n  {getField({vecToString(curPos)})} != \"S\",\\\n  innerLoop2,\\\n  if(lootPositions != \"\", loop2, end)\\\n))\n\nend:\n"],["find path",":import adventure_lib\n:name {package}:find path\n\n:budget_cap 1\n\n:global string leon.adventure.path\n\n:local vector curPos\n:local string queue\n:local string idx\n:local string dir\n:local string path\n:local bool cantPhase\n\n#setField(index, value) lss(\"_f\" . {index}, {value})\n#getField(index) lsg(\"_f\" . {index})\n\nleon.adventure.path = \"\"\ncantPhase = not(adventure.hasItem(\"bootsPhasing\"))\\\n|| 0 < max(\\\n  max(\\\n    adventure.countEntities(\"Elite\"),\\\n    adventure.countEntities(\"Chest\")\\\n  ),\\\n  adventure.countEntities(\"Enemy\")\\\n)\nqueue = {vecToString(adventure.playerPos())} . \"S:\"\n\nloop1:\ncurPos = {firstElementPos}\nidx = sub(queue, 0, 4)\n; if this field is already set, we set an empty field to the direction\n; otherwise, it's empty and we assign it to idx\n{setField(if(contains(\"\", {getField(idx)}), idx, \"\"), {firstElementDir})}\n; \nqueue = if(\\\n  {getField(idx)} != {firstElementDir},\\\n  sub(queue, 6, 99999),\\\n  sub(queue, 6, 99999) . if(\\\n    adventure.isWall(curPos + vec(0.0, 1.0)) && cantPhase\\\n      || max(x(curPos), y(curPos)) >= 18.0\\\n      || x(curPos) < 1.0,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) + 1.0)} . \"U:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(0.0, -1.0)) && cantPhase\\\n      || min(x(curPos), y(curPos)) < 1.0\\\n      || x(curPos) >= 18.0,\\\n    \"\",\\\n    {posToString(x(curPos), y(curPos) - 1.0)} . \"D:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(1.0, 0.0)) && cantPhase\\\n      || max(x(curPos), y(curPos)) >= 18.0\\\n      || y(curPos) < 1.0,\\\n    \"\",\\\n    {posToString(x(curPos) + 1.0, y(curPos))} . \"R:\"\\\n  ) . if(\\\n    adventure.isWall(curPos + vec(-1.0, 0.0)) && cantPhase\\\n      || min(x(curPos), y(curPos)) < 1.0\\\n      || y(curPos) >= 18.0,\\\n    \"\",\\\n    {posToString(x(curPos) - 1.0, y(curPos))} . \"L:\"\\\n  )\\\n)\ngoto(if(\\\n  contains(\"\", queue) || contains(idx, sub({target.getPositions}, 0, 4)),\\\n  l2start,\\\n  loop1\\\n))\n\nloop2:\nleon.adventure.path = dir . leon.adventure.path\ncurPos -= {nextDir(dir)}\nidx = {vecToString(curPos)}\n\nl2start:\ndir = {getField(idx)}\ngotoif(loop2, dir != \"S\")\n\nexecutesync(\"{package}:refine path\")\n"],["follow path",":import adventure_lib\n:name {package}:follow path\n\n:budget_cap max\n\n:global string leon.adventure.path\n\n:local int stepCount\n:local vector curPos\n:local bool waitChest\n:local vector nextMove\n\n#nextDirection sub(leon.adventure.path, stepCount, 1)\n#nextMove {nextDir({nextDirection})}\n#nextTile adventure.entityType(adventure.playerPos() + nextMove)\n#curEntity adventure.entityType(curPos + {nextDir({nextDirection})})\n\ngoto(if(isopen(\"arcade\") && {state.get}, start, end))\n\nbomb:\nadventure.placeBomb()\ngoto(move)\n\nwait:\nadventure.wait()\n\nmove:\nstepCount = stepCount + 1\n\nstart:\ncurPos = adventure.playerPos()\nnextMove = {nextMove}\nwaitChest = contains({nextTile}, \"Chest\")\n\nmove2:\nwaitframe()\nadventure.move(nextMove)  ; This is a no-op for invalid (0,0) moves\n\nloop:\n; This uses the spacing of unused values in the index expression to be\n; equivalent to lines to skip *backward*. This is much cheaper than having\n; a nested ternary.\n; index returns -1 for the fallthrough case, making UDLR place us at move\n\ngotoif(\\\n  if(\\\n    contains(\"BW\", {nextDirection})\\\n      || x(curPos) != x(adventure.playerPos())\\\n      || y(curPos) != y(adventure.playerPos())\\\n      || waitChest && contains(\"\", {nextTile}),\\\n    wait - index(\"W B\", {nextDirection}, 0),\\\n    move2\\\n  ),\\\n  stepCount < len(leon.adventure.path) && {state.get} && isopen(\"arcade\")\\\n)\nend:\n"],["refine path",":import adventure_lib\n:name {package}:refine path\n\n:budget_cap max\n\n:global string leon.adventure.path\n\n:local vector curPos\n:local int stepCount\n\n#has_hammer adventure.hasItem(\"hammer\")\n\n#curDirection sub(leon.adventure.path, stepCount, 1)\n#insert(st,i,val) sub({st},0,{i}) . ({val}) . sub({st},{i},99999)\n#escapeDirection if(\\\n  adventure.entityType(curPos + vec(0., 1.)) == \"\"\\\n    && adventure.entityType(curPos + vec(0., 2.)) == \"\"\\\n    && not(adventure.isWall(curPos + vec(0., 1.)))\\\n    && y(curPos) < 17.0,\\\n  \"BUUWDD\",\\\n  if(\\\n    adventure.entityType(curPos + vec(0., -1.)) == \"\"\\\n      && adventure.entityType(curPos + vec(0., -2.)) == \"\"\\\n      && not(adventure.isWall(curPos + vec(0., -1.)))\\\n      && y(curPos) > 1.0,\\\n    \"BDDWUU\",\\\n    if(\\\n      adventure.entityType(curPos + vec(-1., 0.)) == \"\"\\\n        && adventure.entityType(curPos + vec(-2., 0.)) == \"\"\\\n        && not(adventure.isWall(curPos + vec(-1., 0.)))\\\n        && x(curPos) > 1.0,\\\n      \"BLLWRR\",\\\n      \"BRRWLL\"\\\n    )\\\n  )\\\n)\n\ncurPos = adventure.playerPos()\ngoto(start)\n\nrock:\nleon.adventure.path = {insert(\\\n  leon.adventure.path,\\\n  stepCount,\\\n  if(adventure.hasItem(\"eodArmor\"), \"BWWW\", {escapeDirection})\\\n)}\nstepCount += if(adventure.hasItem(\"eodArmor\"), 4, 6)\n\nnextTile:\ncurPos = curPos + {nextDir({curDirection})}\nstepCount = stepCount + 1\n\n#move_dir adventure.entityType(curPos + {nextDir({curDirection})})\nstart:\ngotoif(\\\n  if(\\\n    {move_dir} != \"Rock\" || {has_hammer},\\\n    nextTile,\\\n    rock\\\n  ),\\\n  stepCount < len(leon.adventure.path)\\\n)\nend:\n"],["adventure_lib","#package Adventure v3.3.7\n\n; key assignment macros\n#start r\n#reinit i\n; \n#up u\n#down j\n; \n#kill k\n\n; lua macro that makes sure the export code doesn't have\n; duplicate impulse keys.\n{lua(\\\n  local imp = {};\\\n  local keys = \"{start}|{reinit}|{up}|{down}|{kill}|\";\\\n  for word in keys:gmatch(\"[^|]+\") do\\\n    if imp[word] then error(\"key. impulses can't have duplicates\", 0) end\\\n    imp[word] = 1;\\\n  end\\\n)}\n\n; \n; a string holding our direction sequence\n#dir_list \"ULRD\"\n\n; macro that returns a spaced out version of our dir_list\n; requires the ammount of spaces, a negative input\n; returns spaces before the direction\n; 01 => \"R \"\n; -1 => \" R\"\n#dir_spaced(space) {lua(\\\n  local directions = {};\\\n  local space = {space} < 0 and 1 - {space} or -1 - {space};\\\n  local spacer = \"%\" .. space .. \"s\";\\\n  for i = 1, #{dir_list} do\\\n    directions[i] = spacer:format(string.sub({dir_list}, i, i));\\\n  end\\\n  return table.concat(directions);\\\n)}\n\n; The name of the variable that stores \"target positions\" state.\n; Doubles as the start of the variable-hiding block.\n:const string target_pos_var \"<size=0>adv.target_pos\"\n#target.getPositions global.string.get(target_pos_var)\n#target.setPos(position) global.string.set(target_pos_var, {position})\n\n; The state of the script.\n:const string state \"leon.adventure.running\"\n#state.get global.bool.get(state)\n#state.set(value) global.bool.set(state, {value})\n\n; Convert a coordinate into stringified form.\n#coordToString(coord) sub(d2s(200.0 + ({coord})), 1, 2)\n; Convert a vector that has been pre-split into its two components into\n; stringified form. This only works for non-negative numbers.\n#posToString(x, y) {coordToString({x})} . {coordToString({y})}\n\n; Split a vector into its 2 components to be processed by posToString\n#vecToString(vector) {posToString(x({vector}), y({vector}))}\n\n; Convert a string to a coordinate.\n#strToCoord(str, offset) s2d(sub({str}, {offset}, 2), -1.0)\n\n; Convert a length-4 stringified vector to vector form.\n; This evaluates str twice, so that should be a small expression.\n; This *will* work with negative values, if they're small enough.\n#strToVec(str) vec({strToCoord({str}, 0)}, {strToCoord({str}, 2)})\n\n; Macros for working with BFS queues. The queue is structured as a\n; length-4 stringified position followed by a length-1 direction.\n#firstElementPos {strToVec(queue)}\n#firstElementDir sub(queue, 4, 1)\n\n; Calculate the difficulty of the room the player is in.\n; This formulation is a bit harder to follow than the traditional one\n; that uses absolute values, but it require fewer operations.\n;\n; This takes a parameter \"offset\", which is added to the difficulty.\n; This exists because it can be constant-folded in to this calculation,\n; whereas if we add it later it's a separate addition.\n#cur_difficulty(offset) (\\\n  max(\\\n    254. - x(adventure.roomCoords()),\\\n    x(adventure.roomCoords())\\\n  ) + max(\\\n    254. - y(adventure.roomCoords()),\\\n    y(adventure.roomCoords())\\\n  ) + ({offset} - 254.)\\\n)\n\n; Calculate if the given difficulty (i.e. distance) is \"survivable\",\n; i.e. can be cleared automatically without taking damage. This includes\n; comparing against maxDifficulty, which technically doesn't affect your\n; ability to survive, but does determine how the AI chooses rooms.\n#survivable(difficulty) (\\\n  {difficulty} < 100.0 || \\\n  adventure.hasItem(\"lantern\")\\\n) && leon.adventure.maxDifficulty >= {difficulty} && (\\\n  i2d(adventure.playerArmor()) >= ceil({difficulty} * 0.39) || if(\\\n    adventure.hasItem(\"impaler\"), \\\n    ceil(i2d(adventure.playerAttack()) * 1.1),\\\n    i2d(adventure.playerAttack())\\\n  ) >= round({difficulty} * 0.38 + 1.) + round({difficulty} * 0.08)\\\n)\n\n\n; Convert a U/D/R/L direction into a direction vector by using index\n; and lookup tables. These are arranged so that if the lookup fails\n; (i.e. if the direction is \"W\" for wait),\n; the s2d will default to (0.,0.).\n#nextX(d) s2d(sub(\"X 0 0 1-1\", index(\" U D R L\", {d}, 0), 2), 0.)\n#nextY(d) s2d(sub(\"X 1-1 0 0\", index(\" U D R L\", {d}, 0), 2), 0.)\n#nextDir(d) vec({nextX({d})}, {nextY({d})})\n"]]}}
```

### v3.3.7

Fixed the order of the contains in the state toggle. non_kill and impulse() were swapped in the contains.<br>
Changed the kill_enemies loop to be a goto(if()) instead of a gotoif().<br>
Added a lua macro that doesn't let the script compile if the impulse keys have duplicate. Can't have 2 different impulses have the same key.<br>
Macro `{target_positions}` is now called `{target.getPositions}`.<br>
Added `{target.setPos}` to set a target position.<br>
impulse `key.{kill}` now enters farm keys to get our resources up.<br>
Fixed broken logic. I made find path think that it could phase when it couldn't.

### v3.3.6

Added `dir_spaced` macro that takes a number `space` and adds space amount of `spaces` inbetween each of the direction letters.
`"{dir_spaced(4)}" = "U    L    R    D    "` and `"{dir_spaced(-4)}" = "    U    L    R    D"`

Made all impulses be inside of init.<br>
`key.{kill}` now always shuts off the AI.<br>
scripts `kill enemies`, `farm keys` and `find loot` are now completely inside of init.

### v3.3.5

Added key assignment macros in adventure_lib.<br>
Cleaned up a little bit of the logic with `not()`, `contains()` and macros.<br>
Added Editor_actions lib dependency for [kill enemies](kill%20enemies.tpt2).<br>
Added some more comments in hopes to understand the script better.

### V3.3.1

Replaced turbo implementation with budget system.<br>
Init now corelates with the workspace contents.<br>

### V3.3

Bugfixes, market buying, and size reduction.

New feature: Auto-buys items from the emerald market. If you don't like the
order it buys things in, tough. It's optimized for improving the speed of the
AI, and it will buy all the items relatively quickly.

Because of auto-buying, the AI will now reach the default maxDifficulty on its
own without cheat armor or player intervention.

Fix: Buying the mana sword before the spellbook no longer puts the AI in a room-loop.

Fix: Handling of impulses is greatly improved. It should be impossible to get
into weird states by pressing keys rapidly now. You can press either "R" or "K"
to cancel the AI when it's running, and it will always stop what it's doing.

Fix: Make leaving the Arcade properly shutdown in all cases.

Eliminated a script via code combining.

```
Bundle size: 8636 (51531 uncompressed)   Scripts: 8   Max lines: 17
```

### V3.2

Efficient bomb/health/mana grinding.

Grinding only happens when you have the appropriate items for it (leech and/or mana sword).
When grinding bombs, rooms will be skipped if they don't contain elites. The
time ends up dominated by how much health you lose, so grinding at either d80
or d100 is best.

```
Bundle size: 49192   Scripts: 9   Max lines: 17
```

### V3.1

Major bugfixes. Major size reduction.

Basic mimic handling, although it takes 2x as much damage as it needs to.

Boots of Phasing are used, Voidforged Impaler effect is accounted for in
determining maximum distance.

```
Bundle size: 43160   Scripts: 9   Max lines: 17
```

### V3.0

First release under new management!

Checks relics for EODArmor instead of assuming you have it at distance 50, and
uses hammer when possible instead of bombing all rocks.

Significantly smaller.

```
Bundle size: 98476   Scripts: 9   Max lines: 17
```

### V2.0.1

Last version by xWar131x.

```
Bundle size: 138196  Scripts: 9   Max lines: 18
```
