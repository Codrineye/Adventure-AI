:import adventure_lib
:name {package}:find path

:global string leon.adventure.path
:global double leon.adventure.target_pos
:global int turbo.cycles.max
:global int turbo.cycles

:local double curPos
:local string queue
:local string field
:local string path

#distance(x,y) ({x}%19.)-({y}%19.)+floor({x}/19.)-floor({y}/19.)

start:
turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)
queue = {posToString(x(adventure.playerPos()) + 19. * y(adventure.playerPos()))} . "S:"
field = "{lua(return string.rep("0",362))}"
loop1:
    curPos = {firstElementPos}
    field = {replace(field, d2i(curPos), {firstElementDir}, 1)}
    {pop}
    queue= queue .\
        if(false == adventure.isWall({posToVec({goUp})}) && \
            false == contains(queue,{posToString({goUp})}) && \
            {goUp}<361. &&\
            sub(field,d2i({goUp}),1)=="0" ,\
            concat({posToString({goUp})},"U:"),"") .\
        if(false == adventure.isWall({posToVec({goDown})}) && \
            false == contains(queue,{posToString({goDown})}) && \
            {goDown}>=0. &&\
            sub(field,d2i({goDown}),1)=="0" , \
            {posToString({goDown})} . "D:", "") .\
        if(false == adventure.isWall({posToVec({goRight})}) && \
            false == contains(queue,{posToString({goRight})}) && \
            sub(field,d2i({goRight}),1)=="0"&&\
            {distance({goRight},curPos)}<=1.,\
            {posToString({goRight})} . "R:", "") .\
        if(false == adventure.isWall({posToVec({goLeft})}) && \
            false == contains(queue,{posToString({goLeft})}) && \
            sub(field,d2i({goLeft}),1) == "0"&&\
            {distance({goLeft},curPos)}<=1.,\
            {posToString({goLeft})} . "L:", "")
  gotoif(loop1,len(queue)>0&&curPos!=leon.adventure.target_pos)
loop2:
    path=sub(field,d2i(curPos),1) . path
    curPos=if(sub(path,0,1)=="U",{goDown},if(sub(path,0,1)=="D",{goUp},\
        if(sub(path,0,1)=="R",{goLeft},if(sub(path,0,1)=="L",{goRight},curPos))))
  gotoif(loop2,sub(field,d2i(curPos),1)!="S")
leon.adventure.path = if(path=="S","",path)
executesync("{package}:refine path")
end:
wait(0.0)
