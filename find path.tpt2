:import adventure_lib
:name {package}:find path

:global string leon.adventure.path
:global string leon.adventure.targetPositions
:global int turbo.cycles.max
:global int turbo.cycles

:local vector curPos
:local string queue
:local string idx
:local string path

#setField(index, value) lss("_f" . {index}, {value})
#getField(index) lsg("_f" . {index})

start:
turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)
queue = {posToString(x(adventure.playerPos()), y(adventure.playerPos()))} . "S:"
loop1:
curPos = {firstElementPos}
idx = sub(queue, 0, 4)
{setField(if({getField(idx)} != "", "", idx), {firstElementDir})}
queue = sub(queue, 6, 99999) . if({getField(idx)} != {firstElementDir},\
  "",\
  if(\
    adventure.isWall(curPos + vec(0., 1.)) || y(curPos) >= 18.,\
    "",\
    {posToString(x(curPos), y(curPos) + 1.)} . "U:"\
  ) . if(\
    adventure.isWall(curPos + vec(0., -1.)) || y(curPos) < 1.,\
    "",\
    {posToString(x(curPos), y(curPos) - 1.)} . "D:"\
  ) . if(\
    adventure.isWall(curPos + vec(1., 0.)) || x(curPos) >= 18.,\
    "",\
    {posToString(x(curPos) + 1., y(curPos))} . "R:"\
  ) . if(\
    adventure.isWall(curPos + vec(-1., 0.)) || x(curPos) < 1.,\
    "",\
    {posToString(x(curPos) - 1., y(curPos))} . "L:"\
  )\
)
goto(if(\
  queue == "" || contains(idx, sub(leon.adventure.targetPositions, 0, 4)),\
  l2start,\
  loop1\
))

loop2:
path = {getField(idx)} . path
curPos += {nextDirInverse(sub(path, 0, 1))}
idx = {posToString(x(curPos), y(curPos))}
l2start:
gotoif(loop2, {getField(idx)} != "S")

executesync("{package}:refine path")
wait(0.0)
