:import adventure_lib
:name {package}:farm keys

:budget_cap 1

:global int leon.adventure.maxDifficulty
:global bool leon.adventure.running
:global string leon.adventure.path

:local double difficulty
:local bool parity
:local bool needs_something
:local bool skipped

:local string dir

#can_leech adventure.hasItem("leechSword")
#can_cast adventure.hasItem("bookSpells")

#needs_bombs adventure.bombs() < 99 && difficulty >= 80.0 && {can_leech}
#needs_health adventure.playerHealth() < 99 && {can_leech}
#needs_mana adventure.mana() < 99 && adventure.hasItem("manaReaver") && {can_cast}
#needs_keys adventure.keys() <= 10

#any_needs {needs_bombs} || {needs_health} || {needs_mana} || {needs_keys}

#num_enemies round(difficulty * 0.1 + 3.0)
#elite_dmg d2i(floor(difficulty * 0.01 + 1.0)) * (\
  d2i(ceil(ceil(difficulty * 0.39) * 1.5)) - adventure.playerArmor()\
)

goto(start)

next:
; partity is in charge of making sure we never exit farm keys until
; we're back in the room we started in
parity = not(parity)
adventure.move({nextDir(dir)})
; dir always has a valid exit when we enter next:

start:
difficulty = {cur_difficulty(0.0)}
needs_something = {survivable(difficulty)} && ({any_needs})
dir = sub(\
  "XU   D  L  R", \
  index(" 918 90 09 189", x(adventure.playerPos()) . y(adventure.playerPos()), 0), \
  1\
)
skipped = contains("UDLR", dir) && (\
  (adventure.countEntities("Elite") > 0) != (needs_something && {needs_bombs})\
    && (\
      adventure.countEntities("Elite") > 0 || \
      adventure.playerHealth() > 100 - d2i({num_enemies} * 1.8)\
    )\
    || (adventure.countEntities("Elite") > 0 && adventure.playerHealth() <= {elite_dmg})\
    || (parity && not(needs_something))\
)
; Need to protect against arcade being closed during the loop, because
; executesync will stall forever in that case due to the script condition
executesync(if(\
  skipped || not(isopen("arcade")),\
  "{package}:xNOOPx",\
  "{package}:kill enemies"\
))
; Update needs_something after clearing
goto(if(\
  contains("UDLR", dir) && leon.adventure.running && \
    (needs_something && ({any_needs}) || parity || skipped),\
  next,\
  end\
))
end:
wait(0.0)
