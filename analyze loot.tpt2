:import adventure_lib
:name {package}:analyze loot

:global string leon.adventure.targetPositions

:local string field
:local string queue
:local double curPos
:local double targetPos
:local string insertPosition
:local string lootPositions

#toQueueElement(pos,dir) {posToString({pos})} . {dir} . ":"
#enqueue(pos,dir) queue=queue . {toQueueElement({pos},{dir})}

{enqueue(x(adventure.playerPos())+ 19. * y(adventure.playerPos()),"S")}
field = "{lua(return string.rep("0000",362))}"
loop1:
    curPos = {firstElementPos}
    field = {replace(field, d2i(curPos)*4, {firstElementDir}, 1)}
    {pop}
    queue= queue . if(false == adventure.isWall({posToVec({goUp})}) && \
            false == contains(queue,{posToString({goUp})}) && \
            {goUp}<361. &&\
            sub(field,d2i({goUp})*4,1)=="0" ,\
            {posToString({goUp})} . "U:","") . \
        if(false == adventure.isWall({posToVec({goDown})}) && \
            false == contains(queue,{posToString({goDown})}) && \
            {goDown}>=0. &&\
            sub(field,d2i({goDown})*4,1)=="0" , \
            {posToString({goDown})} . "D:","") .\
        if(false == adventure.isWall({posToVec({goRight})}) && \
            false == contains(queue,{posToString({goRight})}) && \
            sub(field,d2i({goRight})*4,1)=="0"&&\
            floor({goRight}/19.)==floor(curPos/19.),\
            {posToString({goRight})} . "R:","") .\
        if(false == adventure.isWall({posToVec({goLeft})}) && \
            false == contains(queue,{posToString({goLeft})}) && \
            sub(field,d2i({goLeft})*4,1) == "0"&&\
            floor({goLeft}/19.)==floor(curPos/19.),\
            {posToString({goLeft})} . "L:","")
    lootPositions = if(\
        adventure.entityType({posToVec(curPos)})=="Chest",\
        {posToString(curPos)} . ":",\
        "") . lootPositions
  gotoif(loop1,len(queue)>0)
lootPositions = leon.adventure.targetPositions . lootPositions
loop2:
    targetPos = s2d(sub(lootPositions,0,3),0.)
    curPos = targetPos
    lootPositions = sub(lootPositions,4,99999)
    innerLoop2:
    leon.adventure.targetPositions = if(\
      sub(field, d2i({nextFieldInverse(sub(field,d2i(curPos)*4,1))}) * 4, 1) == "S"\
        && false == contains(leon.adventure.targetPositions,{posToString(targetPos)}),\
      {posToString(targetPos)} . ":" . leon.adventure.targetPositions,\
      if(\
        false == contains(leon.adventure.targetPositions,{posToString(targetPos)}) \
          && sub(field,d2i(curPos)*4+1,3) != "000",\
        sub(\
          leon.adventure.targetPositions,\
          0,\
          index(leon.adventure.targetPositions, sub(field, d2i(curPos)*4+1,3),0)\
        ) . {posToString(targetPos)} . ":" .\
        sub(\
          leon.adventure.targetPositions,\
          index(leon.adventure.targetPositions, sub(field,d2i(curPos)*4+1,3),0),\
          99999\
        ),\
        leon.adventure.targetPositions\
      )\
    )
        field = if(false==contains(leon.adventure.targetPositions,{posToString(targetPos)}) ||\
                len(leon.adventure.targetPositions) <= 4 || sub(field,d2i(curPos)*4+1,3)==sub(leon.adventure.targetPositions,index(leon.adventure.targetPositions,{posToString(targetPos)},0)+4,3),\
            {replace(field,d2i(curPos)*4+1,{posToString(targetPos)},3)},field)
        curPos = {nextFieldInverse(sub(field,d2i(curPos)*4,1))}
      goto(if(sub(field,d2i(curPos)*4,1)!="S",innerLoop2,if(len(lootPositions)>0,loop2,end)))
end:
  wait(0.)
