:import adventure_lib
:name {package}:follow path

:budget_cap max

:global string leon.adventure.path

:local int stepCount
:local vector curPos
:local bool waitChest
:local vector nextMove

#nextDirection sub(leon.adventure.path, stepCount, 1)
#nextMove {nextDir({nextDirection})}
#nextTile adventure.entityType(adventure.playerPos() + nextMove)
#curEntity adventure.entityType(curPos + {nextDir({nextDirection})})

goto(if(isopen("arcade") && {state.get}, start, end))

bomb:
adventure.placeBomb()
goto(move)

wait:
adventure.wait()

move:
stepCount = stepCount + 1

start:
curPos = adventure.playerPos()
nextMove = {nextMove}
waitChest = contains({nextTile}, "Chest")

move2:
waitframe()
adventure.move(nextMove)  ; This is a no-op for invalid (0,0) moves

loop:
; This uses the spacing of unused values in the index expression to be
; equivalent to lines to skip *backward*. This is much cheaper than having
; a nested ternary.
; index returns -1 for the fallthrough case, making UDLR place us at move

gotoif(\
  if(\
    contains("BW", {nextDirection})\
      || x(curPos) != x(adventure.playerPos())\
      || y(curPos) != y(adventure.playerPos())\
      || waitChest && contains("", {nextTile}),\
    wait - index("W B", {nextDirection}, 0),\
    move2\
  ),\
  stepCount < len(leon.adventure.path) && {state.get} && isopen("arcade")\
)
end:
